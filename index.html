<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Chess Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 226, 0.2) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundFloat 20s ease-in-out infinite;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.7; }
            33% { transform: scale(1.1) rotate(1deg); opacity: 0.8; }
            66% { transform: scale(0.9) rotate(-1deg); opacity: 0.6; }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 25px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            animation: headerGlow 3s ease-in-out infinite;
        }

        @keyframes headerGlow {
            0%, 100% { box-shadow: 0 20px 40px rgba(0,0,0,0.1), 0 0 30px rgba(102, 126, 234, 0.2); }
            50% { box-shadow: 0 25px 50px rgba(0,0,0,0.15), 0 0 40px rgba(102, 126, 234, 0.4); }
        }

        .title {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbowText 4s ease-in-out infinite;
            text-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        @keyframes rainbowText {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, rgba(46, 213, 115, 0.15), rgba(0, 123, 255, 0.15));
            padding: 12px 20px;
            border-radius: 20px;
            border: 2px solid rgba(46, 213, 115, 0.3);
            background-clip: padding-box;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .control-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .control-group:hover::before {
            left: 100%;
        }

        .control-group:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 25px rgba(46, 213, 115, 0.3);
            border-color: #2ed573;
        }

        .control-group label {
            font-weight: 700;
            color: #ffffff;
            font-size: 0.95rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .control-group select, .start-btn {
            background: linear-gradient(135deg, #2ed573, #17a2b8);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(46, 213, 115, 0.4);
        }

        /* Enhanced dropdown styling */
        .control-group select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            padding-right: 35px;
            min-height: 40px;
        }

        .control-group select option {
            background: linear-gradient(135deg, #2ed573, #17a2b8);
            color: white !important;
            padding: 12px 15px;
            font-weight: 600;
            border: none;
            transition: all 0.3s ease;
            min-height: 45px;
            line-height: 1.4;
            display: block;
        }

        .control-group select option:hover {
            background: linear-gradient(135deg, #4ecdc4, #44a08d) !important;
            color: white !important;
            transform: scale(1.02);
        }

        .control-group select option:checked,
        .control-group select option:selected {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24) !important;
            color: white !important;
            font-weight: 700;
        }

        /* Enhanced visibility for all browsers */
        .control-group select:focus option,
        .control-group select:active option {
            background: linear-gradient(135deg, #2ed573, #17a2b8) !important;
            color: white !important;
            padding: 12px 15px;
            font-weight: 600;
            min-height: 45px;
        }

        .control-group select:focus option:hover,
        .control-group select:active option:hover {
            background: linear-gradient(135deg, #20bf6b, #0fb9b1) !important;
            color: white !important;
        }

        .control-group select:focus option:checked,
        .control-group select:active option:checked {
            background: linear-gradient(135deg, #ff6348, #ff4757) !important;
            color: white !important;
            font-weight: 700;
        }

        /* Firefox specific dropdown styling */
        @-moz-document url-prefix() {
            .control-group select option {
                background-color: #2ed573 !important;
                color: white !important;
                padding: 12px 15px;
                font-weight: 600;
                min-height: 45px;
            }
            
            .control-group select option:hover {
                background-color: #20bf6b !important;
                color: white !important;
            }

            .control-group select option:checked {
                background-color: #ff6348 !important;
                color: white !important;
                font-weight: 700;
            }
        }

        /* Chrome/Safari/Edge specific styling */
        @supports (-webkit-appearance: none) {
            .control-group select option {
                background: #2ed573 !important;
                color: white !important;
                padding: 12px 15px;
                font-weight: 600;
                min-height: 45px;
            }
            
            .control-group select option:hover {
                background: #20bf6b !important;
                color: white !important;
            }

            .control-group select option:checked {
                background: #ff6348 !important;
                color: white !important;
                font-weight: 700;
            }
        }

        .start-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-btn:hover, .control-group select:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(46, 213, 115, 0.5);
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            flex-wrap: wrap;
            max-width: 1400px;
            margin: 0 auto;
        }

        .player-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            min-width: 220px;
            max-width: 280px;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .player-section::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            animation: rotate 4s linear infinite;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .player-section.active::before {
            opacity: 1;
        }

        @keyframes rotate {
            100% { transform: rotate(360deg); }
        }

        .player-section.active {
            transform: scale(1.05);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.3);
            border-color: #4ecdc4;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: 800;
            color: #2c3e50;
            margin-bottom: 12px;
            text-align: center;
            position: relative;
            z-index: 2;
        }

        .player-timer {
            font-size: 2rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 15px;
            position: relative;
            z-index: 2;
        }

        .captured-pieces {
            margin-top: 15px;
            position: relative;
            z-index: 2;
        }

        .captured-pieces h4 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }

        .captured-piece {
            font-size: 1.2rem;
            opacity: 0.7;
            animation: captureFloat 2s ease-in-out infinite;
        }

        @keyframes captureFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }

        .chess-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .board-coordinates {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 16px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 80px);
            grid-template-rows: repeat(8, 80px);
            border: 8px solid transparent;
            border-radius: 20px;
            background: 
                linear-gradient(135deg, #667eea, #764ba2) padding-box,
                linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3) border-box;
            background-size: 400% 400%;
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.3),
                inset 0 0 30px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            animation: boardGlow 4s ease-in-out infinite;
        }

        @keyframes boardGlow {
            0%, 100% { 
                background-position: 0% 50%;
                box-shadow: 
                    0 25px 50px rgba(0,0,0,0.3),
                    inset 0 0 30px rgba(255,255,255,0.1),
                    0 0 40px rgba(102, 126, 234, 0.3);
            }
            50% { 
                background-position: 100% 50%;
                box-shadow: 
                    0 30px 60px rgba(0,0,0,0.4),
                    inset 0 0 40px rgba(255,255,255,0.2),
                    0 0 60px rgba(102, 126, 234, 0.5);
            }
        }

        .chess-board::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 25% 25%, rgba(255, 107, 107, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(78, 205, 196, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(69, 183, 209, 0.05) 0%, transparent 70%);
            animation: boardAmbient 6s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes boardAmbient {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            33% { opacity: 0.5; transform: scale(1.02); }
            66% { opacity: 0.4; transform: scale(0.98); }
        }

        .chess-square {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5rem;
            cursor: pointer;
            position: relative;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
        }

        .chess-square.light {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e, #e17055);
            position: relative;
            overflow: hidden;
        }

        .chess-square.light::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255, 234, 167, 0.8) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(253, 203, 110, 0.6) 0%, transparent 50%);
            animation: lightSquareShimmer 4s ease-in-out infinite;
        }

        @keyframes lightSquareShimmer {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.02); }
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe, #fd79a8);
            position: relative;
            overflow: hidden;
        }

        .chess-square.dark::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(108, 92, 231, 0.7) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(162, 155, 254, 0.5) 0%, transparent 50%);
            animation: darkSquareShimmer 4s ease-in-out infinite reverse;
        }

        @keyframes darkSquareShimmer {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.02); }
        }

        .chess-square:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .chess-square.selected {
            background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
            transform: scale(1.15);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
            animation: selectedPulse 1.5s ease-in-out infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { 
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 215, 0, 1), inset 0 0 30px rgba(255, 255, 255, 0.5);
            }
        }

        .chess-square.legal-move {
            background: linear-gradient(135deg, #00ff88, #00cc6a) !important;
            animation: legalMoveGlow 2s ease-in-out infinite;
        }

        @keyframes legalMoveGlow {
            0%, 100% { 
                box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
            }
            50% { 
                box-shadow: 0 0 25px rgba(0, 255, 136, 0.9);
            }
        }

        .chess-square.legal-move::after {
            content: '●';
            position: absolute;
            font-size: 2rem;
            color: #006400;
            animation: moveIndicator 1.5s ease-in-out infinite;
        }

        .chess-square.legal-move.has-piece::after {
            content: '⚔';
            font-size: 2.5rem;
            color: #dc143c;
        }

        @keyframes moveIndicator {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .chess-square.in-check {
            background: linear-gradient(135deg, #ff4757, #ff3838) !important;
            animation: checkWarning 1s ease-in-out infinite;
        }

        @keyframes checkWarning {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 71, 87, 0.8);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 30px rgba(255, 71, 87, 1);
                transform: scale(1.05);
            }
        }

        .chess-square.castle-move {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7) !important;
            animation: castleGlow 2s ease-in-out infinite;
        }

        @keyframes castleGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(162, 155, 254, 0.6); }
            50% { box-shadow: 0 0 25px rgba(162, 155, 254, 0.9); }
        }

        .chess-square.castle-move::after {
            content: '🏰';
            position: absolute;
            font-size: 1.5rem;
            animation: castleIndicator 1.5s ease-in-out infinite;
        }

        @keyframes castleIndicator {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .piece {
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            position: relative;
            z-index: 2;
            animation: pieceFloat 3s ease-in-out infinite;
            cursor: pointer;
        }

        @keyframes pieceFloat {
            0%, 100% { transform: translateY(0px) rotateZ(0deg); }
            33% { transform: translateY(-2px) rotateZ(1deg); }
            66% { transform: translateY(-1px) rotateZ(-1deg); }
        }

        .piece.white {
            color: #ffffff;
            text-shadow: 
                2px 2px 6px rgba(0,0,0,0.8), 
                0 0 10px rgba(255,255,255,0.5),
                0 0 20px rgba(255,215,0,0.3);
            animation: pieceFloat 3s ease-in-out infinite, whiteGlow 4s ease-in-out infinite;
        }

        @keyframes whiteGlow {
            0%, 100% { 
                text-shadow: 
                    2px 2px 6px rgba(0,0,0,0.8), 
                    0 0 10px rgba(255,255,255,0.5),
                    0 0 20px rgba(255,215,0,0.3);
            }
            50% { 
                text-shadow: 
                    2px 2px 6px rgba(0,0,0,0.8), 
                    0 0 15px rgba(255,255,255,0.8),
                    0 0 30px rgba(255,215,0,0.6);
            }
        }

        .piece.black {
            color: #2c3e50;
            text-shadow: 
                2px 2px 6px rgba(255,255,255,0.3), 
                0 0 10px rgba(44,62,80,0.7),
                0 0 20px rgba(108,92,231,0.4);
            animation: pieceFloat 3s ease-in-out infinite, blackGlow 4s ease-in-out infinite;
        }

        @keyframes blackGlow {
            0%, 100% { 
                text-shadow: 
                    2px 2px 6px rgba(255,255,255,0.3), 
                    0 0 10px rgba(44,62,80,0.7),
                    0 0 20px rgba(108,92,231,0.4);
            }
            50% { 
                text-shadow: 
                    2px 2px 6px rgba(255,255,255,0.3), 
                    0 0 15px rgba(44,62,80,1),
                    0 0 30px rgba(108,92,231,0.7);
            }
        }

        .piece:hover {
            transform: scale(1.3) translateY(-8px) rotateZ(5deg);
            filter: drop-shadow(8px 8px 20px rgba(0,0,0,0.8));
            animation: pieceHover 0.6s ease-in-out infinite;
        }

        @keyframes pieceHover {
            0%, 100% { transform: scale(1.3) translateY(-8px) rotateZ(5deg); }
            50% { transform: scale(1.35) translateY(-12px) rotateZ(-5deg); }
        }

        .piece.moving {
            animation: pieceMove 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 100;
        }

        @keyframes pieceMove {
            0% { 
                transform: scale(1) rotateZ(0deg); 
                filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            }
            25% { 
                transform: scale(1.4) translateY(-15px) rotateZ(10deg); 
                filter: drop-shadow(10px 10px 25px rgba(0,0,0,0.8));
            }
            75% { 
                transform: scale(1.2) translateY(-8px) rotateZ(-5deg); 
                filter: drop-shadow(8px 8px 20px rgba(0,0,0,0.6));
            }
            100% { 
                transform: scale(1) rotateZ(0deg); 
                filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            }
        }

        .piece.captured {
            animation: pieceCaptured 1s ease-in-out forwards;
        }

        @keyframes pieceCaptured {
            0% { 
                transform: scale(1) rotateZ(0deg); 
                opacity: 1;
            }
            50% { 
                transform: scale(1.5) rotateZ(180deg) translateY(-20px); 
                opacity: 0.7;
            }
            100% { 
                transform: scale(0) rotateZ(360deg) translateY(-40px); 
                opacity: 0;
            }
        }

        .game-status {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-top: 20px;
            text-align: center;
            color: #2c3e50;
            font-size: 1.3rem;
            font-weight: 700;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.5s ease;
        }

        .game-status.check {
            background: linear-gradient(135deg, #ff4757, #ff3838);
            color: white;
            animation: checkAlert 1s ease-in-out infinite;
        }

        @keyframes checkAlert {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .game-status.checkmate {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #2c3e50;
            animation: victoryDance 2s ease-in-out infinite;
        }

        @keyframes victoryDance {
            0%, 100% { transform: scale(1) rotateZ(0deg); }
            25% { transform: scale(1.1) rotateZ(2deg); }
            75% { transform: scale(1.1) rotateZ(-2deg); }
        }

        .thinking-indicator {
            display: none;
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            padding: 12px 20px;
            border-radius: 15px;
            font-weight: 600;
            margin-top: 15px;
            animation: thinking 1.5s ease-in-out infinite;
            position: relative;
            z-index: 2;
        }

        .thinking-indicator.show {
            display: block;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .move-history {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 12px;
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
            position: relative;
            z-index: 2;
        }

        .move-history h4 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .move-item {
            padding: 4px 8px;
            margin: 2px 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(78, 205, 196, 0.1));
            border-radius: 6px;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .move-item:hover {
            transform: translateX(5px);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(78, 205, 196, 0.2));
        }

        .undo-controls {
            margin-top: 12px;
            text-align: center;
        }

        .undo-btn {
            background: linear-gradient(135deg, #ff7675, #fd79a8);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            font-size: 0.8rem;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 15px rgba(255, 118, 117, 0.3);
            position: relative;
            overflow: hidden;
        }

        .undo-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .undo-btn:hover::before {
            left: 100%;
        }

        .undo-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 118, 117, 0.5);
        }

        .undo-btn:disabled {
            background: linear-gradient(135deg, #b2bec3, #636e72);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .undo-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        /* Player Statistics */
        .player-stats {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
            position: relative;
            z-index: 2;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .stat-label {
            color: #2c3e50;
            font-weight: 600;
        }

        .stat-value {
            color: #667eea;
            font-weight: 700;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Hint Button */
        .hint-btn {
            background: linear-gradient(135deg, #feca57, #ff9ff3);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            font-size: 0.8rem;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 15px rgba(254, 202, 87, 0.3);
            margin-left: 8px;
            position: relative;
            overflow: hidden;
        }

        .hint-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .hint-btn:hover::before {
            left: 100%;
        }

        .hint-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(254, 202, 87, 0.5);
        }

        /* AI Analysis */
        .ai-analysis {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 12px;
            margin-top: 15px;
            position: relative;
            z-index: 2;
        }

        .ai-analysis h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .analysis-bar {
            background: linear-gradient(90deg, #ff6b6b 0%, #feca57 50%, #4ecdc4 100%);
            height: 20px;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .analysis-fill {
            background: rgba(255, 255, 255, 0.3);
            height: 100%;
            width: 50%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .analysis-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: 700;
            font-size: 0.8rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .best-move {
            color: #2c3e50;
            font-weight: 600;
            font-size: 0.8rem;
            text-align: center;
        }

        /* Achievement Notification */
        .achievement-notification {
            position: fixed;
            top: 20px;
            right: -400px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
            z-index: 1001;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 3px solid #fff;
            max-width: 350px;
        }

        .achievement-notification.show {
            right: 20px;
            animation: achievementBounce 0.6s ease-out;
        }

        @keyframes achievementBounce {
            0% { transform: scale(0.3) rotate(-10deg); }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .achievement-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .achievement-icon {
            font-size: 3rem;
            animation: achievementGlow 2s ease-in-out infinite;
        }

        @keyframes achievementGlow {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.2); }
        }

        .achievement-text {
            flex: 1;
        }

        .achievement-title {
            font-size: 1.2rem;
            font-weight: 800;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .achievement-description {
            font-size: 1rem;
            color: #2c3e50;
            font-weight: 600;
        }

        /* Puzzle Panel */
        .puzzle-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 25px;
            margin: 20px auto;
            max-width: 600px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .puzzle-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .puzzle-header h3 {
            color: #2c3e50;
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .puzzle-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.9rem;
            color: #667eea;
            font-weight: 600;
        }

        .puzzle-objective {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(78, 205, 196, 0.1));
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 1rem;
        }

        .puzzle-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .puzzle-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .puzzle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        /* Board Themes */
        .chess-board.neon {
            background: 
                linear-gradient(135deg, #0f0f23, #1a1a2e) padding-box,
                linear-gradient(45deg, #00ff88, #00ccff, #ff00ff, #ffff00) border-box;
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.8),
                inset 0 0 30px rgba(0, 255, 136, 0.2),
                0 0 60px rgba(0, 255, 136, 0.4);
        }

        .chess-board.neon .chess-square.light {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            box-shadow: inset 0 0 20px rgba(0, 255, 136, 0.1);
        }

        .chess-board.neon .chess-square.dark {
            background: linear-gradient(135deg, #0f0f23, #0a0a1a);
            box-shadow: inset 0 0 20px rgba(0, 204, 255, 0.1);
        }

        .chess-board.wood {
            background: 
                linear-gradient(135deg, #8b4513, #a0522d) padding-box,
                linear-gradient(45deg, #daa520, #cd853f, #8b4513, #654321) border-box;
        }

        .chess-board.wood .chess-square.light {
            background: linear-gradient(135deg, #deb887, #f5deb3, #d2b48c);
        }

        .chess-board.wood .chess-square.dark {
            background: linear-gradient(135deg, #8b4513, #a0522d, #654321);
        }

        .chess-board.marble {
            background: 
                linear-gradient(135deg, #f8f8ff, #e6e6fa) padding-box,
                linear-gradient(45deg, #dda0dd, #d8bfd8, #dda0dd, #e6e6fa) border-box;
        }

        .chess-board.marble .chess-square.light {
            background: linear-gradient(135deg, #f8f8ff, #f0f8ff, #e6e6fa);
        }

        .chess-board.marble .chess-square.dark {
            background: linear-gradient(135deg, #dda0dd, #d8bfd8, #c8a2c8);
        }

        .chess-board.space {
            background: 
                linear-gradient(135deg, #0c0c0c, #1a1a1a) padding-box,
                linear-gradient(45deg, #4b0082, #8a2be2, #9400d3, #4169e1) border-box;
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.9),
                inset 0 0 30px rgba(75, 0, 130, 0.3),
                0 0 60px rgba(138, 43, 226, 0.4);
        }

        .chess-board.space .chess-square.light {
            background: linear-gradient(135deg, #2f2f2f, #404040);
            box-shadow: inset 0 0 15px rgba(138, 43, 226, 0.1);
        }

        .chess-board.space .chess-square.dark {
            background: linear-gradient(135deg, #0c0c0c, #1a1a1a);
            box-shadow: inset 0 0 15px rgba(75, 0, 130, 0.2);
        }

        .chess-board.ocean {
            background: 
                linear-gradient(135deg, #006994, #0077be) padding-box,
                linear-gradient(45deg, #00ced1, #20b2aa, #4682b4, #5f9ea0) border-box;
        }

        .chess-board.ocean .chess-square.light {
            background: linear-gradient(135deg, #87ceeb, #b0e0e6, #add8e6);
        }

        .chess-board.ocean .chess-square.dark {
            background: linear-gradient(135deg, #4682b4, #5f9ea0, #708090);
        }

        /* Victory Celebration Popup */
        .victory-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .victory-popup.show {
            display: flex;
            animation: popupFadeIn 0.5s ease-out;
        }

        @keyframes popupFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .victory-content {
            background: linear-gradient(135deg, #ffd700, #ffed4e, #feca57);
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            box-shadow: 0 30px 60px rgba(0,0,0,0.5);
            border: 5px solid #fff;
            position: relative;
            overflow: hidden;
            animation: victoryBounce 1s ease-out;
            max-width: 90vw;
            max-height: 90vh;
        }

        @keyframes victoryBounce {
            0% { transform: scale(0.3) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .victory-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: victorySparkle 3s linear infinite;
        }

        @keyframes victorySparkle {
            100% { transform: rotate(360deg); }
        }

        .victory-title {
            font-size: 4rem;
            font-weight: 900;
            color: #2c3e50;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            position: relative;
            z-index: 2;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .victory-message {
            font-size: 1.8rem;
            color: #2c3e50;
            margin-bottom: 30px;
            font-weight: 700;
            position: relative;
            z-index: 2;
        }

        .victory-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
            z-index: 2;
        }

        .victory-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .victory-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.6);
        }

        .victory-btn.restart {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .victory-btn.restart:hover {
            box-shadow: 0 15px 35px rgba(255, 107, 107, 0.6);
        }

        /* Flying Flowers Animation */
        .flower {
            position: absolute;
            font-size: 2rem;
            pointer-events: none;
            z-index: 999;
            animation: flyFlower 4s ease-out forwards;
        }

        @keyframes flyFlower {
            0% {
                transform: translateY(100vh) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) rotate(36deg) scale(1);
            }
            90% {
                opacity: 1;
                transform: translateY(-10vh) rotate(720deg) scale(1);
            }
            100% {
                transform: translateY(-20vh) rotate(720deg) scale(0);
                opacity: 0;
            }
        }

        /* Confetti Animation */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            pointer-events: none;
            z-index: 998;
            animation: confettiFall 3s ease-out forwards;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        @keyframes achievementFlash {
            0% { background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); }
            50% { background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #feca57 100%); }
            100% { background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); }
        }

        /* Enhanced Board Animations from Version 2 */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 100px);
            grid-template-rows: repeat(8, 100px);
            border: 8px solid transparent;
            border-radius: 20px;
            background: 
                linear-gradient(135deg, #667eea, #764ba2) padding-box,
                linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3) border-box;
            background-size: 400% 400%;
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.3),
                inset 0 0 30px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            animation: boardGlow 4s ease-in-out infinite, boardFloat 6s ease-in-out infinite;
        }

        @keyframes boardFloat {
            0%, 100% { 
                transform: translateY(0px) rotateX(0deg) rotateY(0deg);
            }
            33% { 
                transform: translateY(-5px) rotateX(2deg) rotateY(1deg);
            }
            66% { 
                transform: translateY(-2px) rotateX(-1deg) rotateY(-2deg);
            }
        }

        .chess-board::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
            background-size: 400% 400%;
            border-radius: 25px;
            z-index: -1;
            animation: borderRainbow 3s ease-in-out infinite;
            filter: blur(15px);
            opacity: 0.7;
        }

        @keyframes borderRainbow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .chess-square {
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4.5rem;
            cursor: pointer;
            position: relative;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            animation: squareBreath 4s ease-in-out infinite;
        }

        @keyframes squareBreath {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .chess-square.light {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e, #e17055);
            position: relative;
            overflow: hidden;
        }

        .chess-square.light::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255, 234, 167, 0.8) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(253, 203, 110, 0.6) 0%, transparent 50%);
            animation: lightSquareShimmer 4s ease-in-out infinite;
        }

        .chess-square.light::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: lightSparkle 3s ease-in-out infinite;
        }

        @keyframes lightSparkle {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe, #fd79a8);
            position: relative;
            overflow: hidden;
        }

        .chess-square.dark::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(108, 92, 231, 0.7) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(162, 155, 254, 0.5) 0%, transparent 50%);
            animation: darkSquareShimmer 4s ease-in-out infinite reverse;
        }

        .chess-square.dark::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, rgba(162, 155, 254, 0.4) 0%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: darkSparkle 3s ease-in-out infinite reverse;
        }

        @keyframes darkSparkle {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .player-section {
                max-width: 600px;
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .chess-board {
                grid-template-columns: repeat(8, 60px);
                grid-template-rows: repeat(8, 60px);
            }
            
            .chess-square {
                width: 60px;
                height: 60px;
                font-size: 2.5rem;
            }
            
            .board-coordinates {
                width: 480px;
            }
            
            .title {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            .chess-board {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }
            
            .chess-square {
                width: 45px;
                height: 45px;
                font-size: 2rem;
            }
            
            .board-coordinates {
                width: 360px;
            }
            
            .victory-content {
                padding: 30px 20px;
                margin: 20px;
            }
            
            .victory-title {
                font-size: 2.5rem;
            }
            
            .victory-message {
                font-size: 1.3rem;
            }
            
            .victory-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .victory-btn {
                width: 100%;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">♔ PROFESSIONAL CHESS ARENA ♛</h1>
        <div class="controls">
            <div class="control-group">
                <label for="gameMode">🎮 Game Mode:</label>
                <select id="gameMode" onchange="updateGameModeDisplay()">
                    <option value="2player">2 Players</option>
                    <option value="computer">vs Computer</option>
                </select>
            </div>
            <div class="control-group" id="difficultyControl" style="display: none;">
                <label for="difficulty">🧠 AI Difficulty:</label>
                <select id="difficulty">
                    <option value="beginner">Beginner (800)</option>
                    <option value="easy">Easy (1200)</option>
                    <option value="medium" selected>Medium (1600)</option>
                    <option value="hard">Hard (2000)</option>
                    <option value="expert">Expert (2400)</option>
                    <option value="grandmaster">Grandmaster (2800)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="timeLimit">⏱️ Time Control:</label>
                <select id="timeLimit">
                    <option value="60">Bullet (1 min)</option>
                    <option value="180">Blitz (3 min)</option>
                    <option value="300" selected>Rapid (5 min)</option>
                    <option value="600">Classical (10 min)</option>
                    <option value="900">Long (15 min)</option>
                    <option value="unlimited">Unlimited</option>
                </select>
            </div>
            <div class="control-group">
                <label for="boardTheme">🎨 Board Theme:</label>
                <select id="boardTheme" onchange="applyBoardTheme()">
                    <option value="classic" selected>Classic</option>
                    <option value="neon">Neon Glow</option>
                    <option value="wood">Wooden</option>
                    <option value="marble">Marble</option>
                    <option value="space">Space</option>
                    <option value="ocean">Ocean</option>
                </select>
            </div>
            <div class="control-group">
                <label for="soundEffects">🔊 Sound:</label>
                <select id="soundEffects" onchange="updateSoundSetting()">
                    <option value="on" selected>On</option>
                    <option value="off">Off</option>
                </select>
            </div>
            <button class="start-btn" onclick="startGame()">🚀 Start Battle</button>
        </div>
    </div>

    <div class="game-container">
        <div class="player-section" id="player1Info">
            <div class="player-name">Player 1 ♔</div>
            <div class="player-timer" id="player1Timer">5:00</div>
            <div class="player-stats">
                <div class="stat-item">
                    <span class="stat-label">Rating:</span>
                    <span class="stat-value" id="player1Rating">1500</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Wins:</span>
                    <span class="stat-value" id="player1Wins">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Material:</span>
                    <span class="stat-value" id="player1Material">39</span>
                </div>
            </div>
            <div class="captured-pieces">
                <h4>Captured Pieces:</h4>
                <div class="captured-list" id="player1Captured"></div>
            </div>
            <div class="move-history">
                <h4>Move History:</h4>
                <div id="moveHistory"></div>
                <div class="undo-controls">
                    <button class="undo-btn" id="undoBtn" onclick="undoLastMove()">
                        ⏪ Undo Move
                    </button>
                    <button class="hint-btn" id="hintBtn" onclick="showHint()">
                        💡 Hint
                    </button>
                </div>
            </div>
        </div>

        <div class="chess-board-container">
            <div class="board-coordinates">
                <span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span>
            </div>
            <div class="chess-board" id="chessBoard"></div>
        </div>

        <div class="player-section" id="player2Info">
            <div class="player-name">Player 2 ♛</div>
            <div class="player-timer" id="player2Timer">5:00</div>
            <div class="player-stats">
                <div class="stat-item">
                    <span class="stat-label">Rating:</span>
                    <span class="stat-value" id="player2Rating">1500</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Wins:</span>
                    <span class="stat-value" id="player2Wins">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Material:</span>
                    <span class="stat-value" id="player2Material">39</span>
                </div>
            </div>
            <div class="captured-pieces">
                <h4>Captured Pieces:</h4>
                <div class="captured-list" id="player2Captured"></div>
            </div>
            <div class="thinking-indicator" id="thinkingIndicator">
                🤖 AI is calculating the perfect move...
            </div>
            <div class="ai-analysis" id="aiAnalysis" style="display: none;">
                <h4>AI Analysis:</h4>
                <div class="analysis-bar">
                    <div class="analysis-fill" id="analysisFill"></div>
                    <span class="analysis-text" id="analysisText">Equal</span>
                </div>
                <div class="best-move" id="bestMove">Best: e2-e4</div>
            </div>
        </div>
    </div>

    <div class="game-status" id="gameStatus">🎯 Configure your game settings and click "Start Battle" to begin the ultimate chess experience! 🎯</div>

    <!-- Achievement Notification -->
    <div class="achievement-notification" id="achievementNotification">
        <div class="achievement-content">
            <div class="achievement-icon">🏆</div>
            <div class="achievement-text">
                <div class="achievement-title">Achievement Unlocked!</div>
                <div class="achievement-description">First Victory</div>
            </div>
        </div>
    </div>



    <!-- Victory Celebration Popup -->
    <div class="victory-popup" id="victoryPopup">
        <div class="victory-content">
            <div class="victory-title" id="victoryTitle">🎉 VICTORY! 🎉</div>
            <div class="victory-message" id="victoryMessage">Congratulations on your amazing win!</div>
            <div class="victory-buttons">
                <button class="victory-btn restart" onclick="closeVictoryPopup(); startGame();">
                    🔄 Play Again
                </button>
                <button class="victory-btn" onclick="closeVictoryPopup();">
                    📊 View Board
                </button>
            </div>
        </div>
    </div>

    <script>
        // Chess pieces using Unicode symbols
        const pieces = {
            'white': {
                'king': '♔', 'queen': '♕', 'rook': '♖', 
                'bishop': '♗', 'knight': '♘', 'pawn': '♙'
            },
            'black': {
                'king': '♚', 'queen': '♛', 'rook': '♜', 
                'bishop': '♝', 'knight': '♞', 'pawn': '♟'
            }
        };

        // Piece values for AI evaluation
        const pieceValues = {
            'pawn': 1, 'knight': 3, 'bishop': 3, 
            'rook': 5, 'queen': 9, 'king': 1000
        };

        // Game state
        let gameState = {
            board: [],
            currentPlayer: 'white',
            selectedSquare: null,
            gameStarted: false,
            gameOver: false,
            player1Time: 300,
            player2Time: 300,
            timer: null,
            gameMode: '2player',
            difficulty: 'medium',
            isComputerTurn: false,
            moveHistory: [],
            gameStateHistory: [], // Store previous game states for undo
            capturedPieces: { white: [], black: [] },
            castlingRights: {
                white: { kingside: true, queenside: true },
                black: { kingside: true, queenside: true }
            },
            kingMoved: { white: false, black: false },
            rookMoved: {
                white: { kingside: false, queenside: false },
                black: { kingside: false, queenside: false }
            },
            enPassantTarget: null,
            isInCheck: { white: false, black: false },
            // New advanced features
            playerStats: {
                player1: { rating: 1500, wins: 0, losses: 0, draws: 0 },
                player2: { rating: 1500, wins: 0, losses: 0, draws: 0 }
            },
            achievements: [],
            boardTheme: 'classic',
            soundEnabled: true,
            hintUsed: false,
            analysisMode: false
        };



        // Achievement system
        const achievements = [
            { id: 'first_win', name: 'First Victory', description: 'Win your first game', icon: '🏆' },
            { id: 'speed_demon', name: 'Speed Demon', description: 'Win a bullet game', icon: '⚡' },
            { id: 'tactician', name: 'Tactician', description: 'Win by checkmate in under 20 moves', icon: '🎯' },
            { id: 'endgame_expert', name: 'Endgame Expert', description: 'Win with only king and queen', icon: '👑' },
            { id: 'comeback_king', name: 'Comeback King', description: 'Win after being down material', icon: '🔄' }
        ];

        // Initialize the chess board
        function initializeBoard() {
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            const initialSetup = [
                ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],
                ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn']
            ];

            // Black pieces
            for (let col = 0; col < 8; col++) {
                board[0][col] = { color: 'black', piece: initialSetup[0][col] };
                board[1][col] = { color: 'black', piece: initialSetup[1][col] };
            }

            // White pieces
            for (let col = 0; col < 8; col++) {
                board[7][col] = { color: 'white', piece: initialSetup[0][col] };
                board[6][col] = { color: 'white', piece: initialSetup[1][col] };
            }

            return board;
        }

        // Render the chess board
        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'chess-square';
                    square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Highlight king if in check
                    const piece = gameState.board[row][col];
                    if (piece && piece.piece === 'king' && gameState.isInCheck[piece.color]) {
                        square.classList.add('in-check');
                    }

                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = `piece ${piece.color}`;
                        pieceElement.textContent = pieces[piece.color][piece.piece];
                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
        }

        // Handle square clicks
        function handleSquareClick(row, col) {
            if (!gameState.gameStarted || gameState.gameOver || gameState.isComputerTurn) return;

            const square = gameState.board[row][col];

            // Clear previous selections and highlights
            clearHighlights();

            if (gameState.selectedSquare) {
                const [selectedRow, selectedCol] = gameState.selectedSquare;
                
                if (row === selectedRow && col === selectedCol) {
                    gameState.selectedSquare = null;
                    return;
                }

                // Try to move piece
                if (isValidMove(selectedRow, selectedCol, row, col)) {
                    const moveResult = movePiece(selectedRow, selectedCol, row, col);
                    if (moveResult) {
                        gameState.selectedSquare = null;
                        switchPlayer();
                        return;
                    }
                }
            }

            // Select piece if it belongs to current player
            if (square && square.color === gameState.currentPlayer) {
                gameState.selectedSquare = [row, col];
                highlightSelectedSquare(row, col);
                highlightLegalMoves(row, col);
            }
        }

        // Clear all highlights
        function clearHighlights() {
            document.querySelectorAll('.chess-square').forEach(sq => {
                sq.classList.remove('selected', 'legal-move', 'has-piece', 'castle-move');
            });
        }

        // Highlight selected square
        function highlightSelectedSquare(row, col) {
            const squareElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            squareElement.classList.add('selected');
        }

        // Highlight all legal moves for selected piece
        function highlightLegalMoves(row, col) {
            const legalMoves = getValidMoves(row, col);
            legalMoves.forEach(([r, c, moveType]) => {
                const squareElement = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                
                if (moveType === 'castle') {
                    squareElement.classList.add('castle-move');
                } else {
                    squareElement.classList.add('legal-move');
                    if (gameState.board[r][c]) {
                        squareElement.classList.add('has-piece');
                    }
                }
            });
        }

        // Check if a square is under attack by the opponent
        function isSquareUnderAttack(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = gameState.board[r][c];
                    if (piece && piece.color === byColor) {
                        if (canPieceAttackSquare(r, c, row, col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Check if a piece can attack a specific square
        function canPieceAttackSquare(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            if (!piece) return false;

            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch (piece.piece) {
                case 'pawn':
                    const direction = piece.color === 'white' ? -1 : 1;
                    return Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction;

                case 'rook':
                    return (fromRow === toRow || fromCol === toCol) && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'bishop':
                    return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'queen':
                    return ((fromRow === toRow || fromCol === toCol) || rowDiff === colDiff) && 
                           isPathClear(fromRow, fromCol, toRow, toCol);

                case 'king':
                    return rowDiff <= 1 && colDiff <= 1;

                case 'knight':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                default:
                    return false;
            }
        }

        // Find king position
        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color && piece.piece === 'king') {
                        return [row, col];
                    }
                }
            }
            return null;
        }

        // Check if king is in check
        function isKingInCheck(color) {
            const kingPos = findKing(color);
            if (!kingPos) return false;
            
            const [kingRow, kingCol] = kingPos;
            const opponentColor = color === 'white' ? 'black' : 'white';
            return isSquareUnderAttack(kingRow, kingCol, opponentColor);
        }

        // Check if move would leave king in check
        function wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // Make temporary move
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            const inCheck = isKingInCheck(piece.color);
            
            // Undo temporary move
            gameState.board[fromRow][fromCol] = piece;
            gameState.board[toRow][toCol] = capturedPiece;
            
            return inCheck;
        }

        // Enhanced move validation with all chess rules
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 ||
                toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;

            const piece = gameState.board[fromRow][fromCol];
            const targetSquare = gameState.board[toRow][toCol];

            if (!piece) return false;
            if (targetSquare && targetSquare.color === piece.color) return false;

            // Check basic piece movement rules
            if (!isBasicMoveValid(fromRow, fromCol, toRow, toCol)) return false;

            // Check if move would leave king in check
            if (wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol)) return false;

            return true;
        }

        // Basic piece movement validation
        function isBasicMoveValid(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const targetSquare = gameState.board[toRow][toCol];
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch (piece.piece) {
                case 'pawn':
                    const direction = piece.color === 'white' ? -1 : 1;
                    const startRow = piece.color === 'white' ? 6 : 1;
                    
                    // Forward move
                    if (fromCol === toCol && !targetSquare) {
                        return (toRow === fromRow + direction) || 
                               (fromRow === startRow && toRow === fromRow + 2 * direction);
                    }
                    // Diagonal capture
                    if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {
                        return targetSquare || isEnPassantCapture(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'rook':
                    return (fromRow === toRow || fromCol === toCol) && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'bishop':
                    return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'queen':
                    return ((fromRow === toRow || fromCol === toCol) || rowDiff === colDiff) && 
                           isPathClear(fromRow, fromCol, toRow, toCol);

                case 'king':
                    // Normal king move
                    if (rowDiff <= 1 && colDiff <= 1) return true;
                    
                    // Castling
                    if (rowDiff === 0 && colDiff === 2) {
                        return canCastle(piece.color, toCol > fromCol ? 'kingside' : 'queenside');
                    }
                    return false;

                case 'knight':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                default:
                    return false;
            }
        }

        // Check if path is clear
        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                if (gameState.board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }

            return true;
        }

        // Check if castling is possible
        function canCastle(color, side) {
            if (gameState.kingMoved[color]) return false;
            if (gameState.rookMoved[color][side]) return false;
            if (isKingInCheck(color)) return false;

            const row = color === 'white' ? 7 : 0;
            const kingCol = 4;
            const rookCol = side === 'kingside' ? 7 : 0;
            const direction = side === 'kingside' ? 1 : -1;

            // Check if squares between king and rook are empty
            for (let col = kingCol + direction; col !== rookCol; col += direction) {
                if (gameState.board[row][col]) return false;
            }

            // Check if king passes through or ends up in check
            const opponentColor = color === 'white' ? 'black' : 'white';
            for (let i = 0; i <= 2; i++) {
                const checkCol = kingCol + (i * direction);
                if (isSquareUnderAttack(row, checkCol, opponentColor)) return false;
            }

            return true;
        }

        // Check if move is en passant capture
        function isEnPassantCapture(fromRow, fromCol, toRow, toCol) {
            if (!gameState.enPassantTarget) return false;
            const [targetRow, targetCol] = gameState.enPassantTarget;
            return toRow === targetRow && toCol === targetCol;
        }

        // Get all valid moves for a piece
        function getValidMoves(row, col) {
            const moves = [];
            const piece = gameState.board[row][col];
            
            if (!piece) return moves;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        // Check if it's a castling move
                        if (piece.piece === 'king' && Math.abs(c - col) === 2) {
                            moves.push([r, c, 'castle']);
                        } else {
                            moves.push([r, c, 'normal']);
                        }
                    }
                }
            }
            return moves;
        }

        // Get all possible moves for a color
        function getAllPossibleMoves(color) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color) {
                        const validMoves = getValidMoves(row, col);
                        validMoves.forEach(move => {
                            moves.push({
                                from: [row, col],
                                to: [move[0], move[1]],
                                piece: piece,
                                moveType: move[2] || 'normal'
                            });
                        });
                    }
                }
            }
            return moves;
        }

        // Check for checkmate or stalemate
        function isCheckmate(color) {
            if (!isKingInCheck(color)) return false;
            return getAllPossibleMoves(color).length === 0;
        }

        function isStalemate(color) {
            if (isKingInCheck(color)) return false;
            return getAllPossibleMoves(color).length === 0;
        }

        // Save current game state for undo functionality
        function saveGameState() {
            const stateCopy = {
                board: gameState.board.map(row => row.map(cell => cell ? {...cell} : null)),
                currentPlayer: gameState.currentPlayer,
                capturedPieces: {
                    white: [...gameState.capturedPieces.white],
                    black: [...gameState.capturedPieces.black]
                },
                castlingRights: {
                    white: {...gameState.castlingRights.white},
                    black: {...gameState.castlingRights.black}
                },
                kingMoved: {...gameState.kingMoved},
                rookMoved: {
                    white: {...gameState.rookMoved.white},
                    black: {...gameState.rookMoved.black}
                },
                enPassantTarget: gameState.enPassantTarget ? [...gameState.enPassantTarget] : null,
                isInCheck: {...gameState.isInCheck},
                player1Time: gameState.player1Time,
                player2Time: gameState.player2Time,
                moveHistory: [...gameState.moveHistory]
            };
            
            gameState.gameStateHistory.push(stateCopy);
            
            // Keep only last 10 moves to prevent memory issues
            if (gameState.gameStateHistory.length > 10) {
                gameState.gameStateHistory.shift();
            }
            
            updateUndoButton();
        }

        // Undo last move
        function undoLastMove() {
            if (gameState.gameStateHistory.length === 0 || gameState.gameOver || 
                (gameState.gameMode === 'computer' && gameState.isComputerTurn)) {
                return;
            }

            // In computer mode, undo both player and AI moves
            if (gameState.gameMode === 'computer' && gameState.gameStateHistory.length >= 2) {
                gameState.gameStateHistory.pop(); // Remove AI move
                if (gameState.gameStateHistory.length > 0) {
                    gameState.gameStateHistory.pop(); // Remove player move
                }
            } else if (gameState.gameStateHistory.length > 0) {
                gameState.gameStateHistory.pop(); // Remove last move
            }

            if (gameState.gameStateHistory.length > 0) {
                const previousState = gameState.gameStateHistory[gameState.gameStateHistory.length - 1];
                
                // Restore game state
                gameState.board = previousState.board.map(row => row.map(cell => cell ? {...cell} : null));
                gameState.currentPlayer = previousState.currentPlayer;
                gameState.capturedPieces = {
                    white: [...previousState.capturedPieces.white],
                    black: [...previousState.capturedPieces.black]
                };
                gameState.castlingRights = {
                    white: {...previousState.castlingRights.white},
                    black: {...previousState.castlingRights.black}
                };
                gameState.kingMoved = {...previousState.kingMoved};
                gameState.rookMoved = {
                    white: {...previousState.rookMoved.white},
                    black: {...previousState.rookMoved.black}
                };
                gameState.enPassantTarget = previousState.enPassantTarget ? [...previousState.enPassantTarget] : null;
                gameState.isInCheck = {...previousState.isInCheck};
                gameState.player1Time = previousState.player1Time;
                gameState.player2Time = previousState.player2Time;
                gameState.moveHistory = [...previousState.moveHistory];
                
                // Remove the state we just restored from history
                gameState.gameStateHistory.pop();
            } else {
                // If no history, reset to initial state
                gameState.board = initializeBoard();
                gameState.currentPlayer = 'white';
                gameState.capturedPieces = { white: [], black: [] };
                gameState.castlingRights = {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                };
                gameState.kingMoved = { white: false, black: false };
                gameState.rookMoved = {
                    white: { kingside: false, queenside: false },
                    black: { kingside: false, queenside: false }
                };
                gameState.enPassantTarget = null;
                gameState.isInCheck = { white: false, black: false };
                gameState.moveHistory = [];
            }

            clearHighlights();
            gameState.selectedSquare = null;
            renderBoard();
            updatePlayerDisplay();
            updateCapturedPieces();
            updateMoveHistory();
            updateGameStatus();
            updateUndoButton();
        }

        // Update undo button state
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            const canUndo = gameState.gameStateHistory.length > 0 && 
                           !gameState.gameOver && 
                           !(gameState.gameMode === 'computer' && gameState.isComputerTurn);
            
            undoBtn.disabled = !canUndo;
        }

        // Move piece with all special rules
        function movePiece(fromRow, fromCol, toRow, toCol) {
            // Save current state before making move
            saveGameState();
            
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // Handle castling
            if (piece.piece === 'king' && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const row = fromRow;
                
                // Move rook
                gameState.board[row][rookToCol] = gameState.board[row][rookFromCol];
                gameState.board[row][rookFromCol] = null;
                
                gameState.kingMoved[piece.color] = true;
                gameState.rookMoved[piece.color][isKingside ? 'kingside' : 'queenside'] = true;
            }

            // Handle en passant capture
            if (piece.piece === 'pawn' && isEnPassantCapture(fromRow, fromCol, toRow, toCol)) {
                const captureRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                const capturedPawn = gameState.board[captureRow][toCol];
                gameState.capturedPieces[capturedPawn.color].push(capturedPawn);
                gameState.board[captureRow][toCol] = null;
            }

            // Set en passant target for next move
            gameState.enPassantTarget = null;
            if (piece.piece === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                gameState.enPassantTarget = [fromRow + (toRow - fromRow) / 2, fromCol];
            }

            // Handle regular capture with animation
            if (capturedPiece) {
                // Add capture animation
                const capturedElement = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"] .piece`);
                if (capturedElement) {
                    capturedElement.classList.add('captured');
                    setTimeout(() => {
                        gameState.capturedPieces[capturedPiece.color].push(capturedPiece);
                        updateCapturedPieces();
                    }, 500);
                } else {
                    gameState.capturedPieces[capturedPiece.color].push(capturedPiece);
                }
            }

            // Move the piece
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;

            // Update castling rights
            if (piece.piece === 'king') {
                gameState.kingMoved[piece.color] = true;
            }
            if (piece.piece === 'rook') {
                if (fromCol === 0) gameState.rookMoved[piece.color].queenside = true;
                if (fromCol === 7) gameState.rookMoved[piece.color].kingside = true;
            }

            // Handle pawn promotion
            if (piece.piece === 'pawn' && (toRow === 0 || toRow === 7)) {
                gameState.board[toRow][toCol] = { color: piece.color, piece: 'queen' };
            }

            // Add move to history
            const moveNotation = `${pieces[piece.color][piece.piece]} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} → ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            gameState.moveHistory.push(moveNotation);

            // Add piece animation
            const pieceElement = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"] .piece`);
            if (pieceElement) {
                pieceElement.classList.add('moving');
                setTimeout(() => pieceElement.classList.remove('moving'), 500);
            }

            renderBoard();
            updateCapturedPieces();
            updateMoveHistory();
            
            return true;
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            const player1Captured = document.getElementById('player1Captured');
            const player2Captured = document.getElementById('player2Captured');
            
            player1Captured.innerHTML = gameState.capturedPieces.black.map(piece => 
                `<span class="captured-piece">${pieces.black[piece.piece]}</span>`
            ).join('');
            
            player2Captured.innerHTML = gameState.capturedPieces.white.map(piece => 
                `<span class="captured-piece">${pieces.white[piece.piece]}</span>`
            ).join('');
        }

        // Update move history display
        function updateMoveHistory() {
            const historyElement = document.getElementById('moveHistory');
            historyElement.innerHTML = gameState.moveHistory.slice(-10).map((move, index) => 
                `<div class="move-item">${gameState.moveHistory.length - 10 + index + 1}. ${move}</div>`
            ).join('');
            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Switch players
        function switchPlayer() {
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            
            // Update check status
            gameState.isInCheck.white = isKingInCheck('white');
            gameState.isInCheck.black = isKingInCheck('black');
            
            updatePlayerDisplay();
            updateGameStatus();
            updateMaterialCount();
            updateAIAnalysis();

            // Reset hint for new turn
            gameState.hintUsed = false;
            document.getElementById('hintBtn').disabled = false;
            document.getElementById('hintBtn').textContent = '💡 Hint';



            // Check for game end conditions
            if (isCheckmate(gameState.currentPlayer)) {
                const winner = gameState.currentPlayer === 'white' ? 'black' : 'white';
                endGameAdvanced(`🎉 CHECKMATE! ${winner === 'white' ? 'White' : 'Black'} wins! 🎉`, 'checkmate', winner);
                return;
            }
            
            if (isStalemate(gameState.currentPlayer)) {
                endGameAdvanced('🤝 STALEMATE! It\'s a draw! 🤝', 'stalemate', 'draw');
                return;
            }

            // Trigger AI move if it's computer's turn
            if (gameState.gameMode === 'computer' && gameState.currentPlayer === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }

        // Update player display
        function updatePlayerDisplay() {
            const player1Info = document.getElementById('player1Info');
            const player2Info = document.getElementById('player2Info');

            player1Info.classList.toggle('active', gameState.currentPlayer === 'white');
            player2Info.classList.toggle('active', gameState.currentPlayer === 'black');
        }

        // Update game status
        function updateGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            
            if (!gameState.gameOver && gameState.gameStarted) {
                let statusText;
                let statusClass = '';
                
                if (gameState.isInCheck[gameState.currentPlayer]) {
                    statusText = `⚠️ CHECK! ${gameState.currentPlayer === 'white' ? 'White' : 'Black'} king is in danger! ⚠️`;
                    statusClass = 'check';
                } else if (gameState.gameMode === 'computer') {
                    statusText = gameState.currentPlayer === 'white' ? 
                        "🎯 Your turn - Make your strategic move! 🎯" : 
                        "🤖 AI is analyzing the position... 🤖";
                } else {
                    const currentPlayerName = gameState.currentPlayer === 'white' ? 'White' : 'Black';
                    statusText = `⚡ ${currentPlayerName}'s turn - Plan your next move! ⚡`;
                }
                
                statusElement.textContent = statusText;
                statusElement.className = `game-status ${statusClass}`;
            }
        }

        // AI move calculation (enhanced)
        function evaluateBoard() {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        let value = pieceValues[piece.piece];
                        
                        // Add positional bonuses
                        if (piece.piece === 'pawn') {
                            // Pawns are more valuable when advanced
                            const advancement = piece.color === 'white' ? (6 - row) : (row - 1);
                            value += advancement * 0.1;
                        }
                        
                        if (piece.piece === 'knight' || piece.piece === 'bishop') {
                            // Knights and bishops are better in center
                            const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);
                            value += (7 - centerDistance) * 0.1;
                        }
                        
                        score += piece.color === 'black' ? value : -value;
                    }
                }
            }
            
            // Add bonus for check
            if (gameState.isInCheck.white) score += 0.5;
            if (gameState.isInCheck.black) score -= 0.5;
            
            return score;
        }

        // Minimax algorithm with alpha-beta pruning
        function minimax(depth, isMaximizing, alpha = -Infinity, beta = Infinity) {
            if (depth === 0) {
                return evaluateBoard();
            }

            const moves = getAllPossibleMoves(isMaximizing ? 'black' : 'white');
            
            if (moves.length === 0) {
                const color = isMaximizing ? 'black' : 'white';
                if (isKingInCheck(color)) {
                    return isMaximizing ? -10000 : 10000; // Checkmate
                } else {
                    return 0; // Stalemate
                }
            }

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const [fromRow, fromCol] = move.from;
                    const [toRow, toCol] = move.to;
                    
                    // Make move
                    const capturedPiece = gameState.board[toRow][toCol];
                    const originalEnPassant = gameState.enPassantTarget;
                    gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                    gameState.board[fromRow][fromCol] = null;

                    const eval = minimax(depth - 1, false, alpha, beta);
                    
                    // Undo move
                    gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                    gameState.board[toRow][toCol] = capturedPiece;
                    gameState.enPassantTarget = originalEnPassant;

                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break; // Alpha-beta pruning
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const [fromRow, fromCol] = move.from;
                    const [toRow, toCol] = move.to;
                    
                    // Make move
                    const capturedPiece = gameState.board[toRow][toCol];
                    const originalEnPassant = gameState.enPassantTarget;
                    gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                    gameState.board[fromRow][fromCol] = null;

                    const eval = minimax(depth - 1, true, alpha, beta);
                    
                    // Undo move
                    gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                    gameState.board[toRow][toCol] = capturedPiece;
                    gameState.enPassantTarget = originalEnPassant;

                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break; // Alpha-beta pruning
                }
                return minEval;
            }
        }

        // Calculate best AI move
        function calculateAIMove() {
            const difficultySettings = getAIDifficulty();
            const moves = getAllPossibleMoves('black');
            
            if (moves.length === 0) return null;

            // Add randomness for easier difficulties
            if (Math.random() < difficultySettings.randomness) {
                return moves[Math.floor(Math.random() * moves.length)];
            }

            let bestMove = null;
            let bestValue = -Infinity;

            for (const move of moves) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                // Make move
                const capturedPiece = gameState.board[toRow][toCol];
                const originalEnPassant = gameState.enPassantTarget;
                gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                gameState.board[fromRow][fromCol] = null;

                const moveValue = minimax(difficultySettings.depth - 1, false);
                
                // Undo move
                gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                gameState.board[toRow][toCol] = capturedPiece;
                gameState.enPassantTarget = originalEnPassant;

                if (moveValue > bestValue) {
                    bestValue = moveValue;
                    bestMove = move;
                }
            }

            return bestMove;
        }

        // Execute AI move
        function makeAIMove() {
            if (gameState.gameMode !== 'computer' || gameState.currentPlayer !== 'black') return;

            gameState.isComputerTurn = true;
            document.getElementById('thinkingIndicator').classList.add('show');

            setTimeout(() => {
                const aiMove = calculateAIMove();
                if (aiMove) {
                    const [fromRow, fromCol] = aiMove.from;
                    const [toRow, toCol] = aiMove.to;
                    movePiece(fromRow, fromCol, toRow, toCol);
                    switchPlayer();
                }
                
                document.getElementById('thinkingIndicator').classList.remove('show');
                gameState.isComputerTurn = false;
            }, Math.random() * 1500 + 1000);
        }

        // Timer functions
        function startTimer() {
            const timeLimit = document.getElementById('timeLimit').value;
            if (timeLimit === 'unlimited') return;

            // Clear any existing timer
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }

            gameState.timer = setInterval(() => {
                if (gameState.gameOver || !gameState.gameStarted) {
                    clearInterval(gameState.timer);
                    return;
                }

                if (gameState.currentPlayer === 'white') {
                    gameState.player1Time--;
                    if (gameState.player1Time <= 0) {
                        gameState.player1Time = 0;
                        clearInterval(gameState.timer);
                        endGame('⏰ Time\'s up! Black wins by timeout! ⏰', 'timeout');
                        return;
                    }
                } else {
                    gameState.player2Time--;
                    if (gameState.player2Time <= 0) {
                        gameState.player2Time = 0;
                        clearInterval(gameState.timer);
                        endGame('⏰ Time\'s up! White wins by timeout! ⏰', 'timeout');
                        return;
                    }
                }
                updateTimerDisplay();
            }, 1000); // Update every second
        }

        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                if (seconds < 0) return "0:00";
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const timeLimit = document.getElementById('timeLimit').value;
            if (timeLimit === 'unlimited') {
                document.getElementById('player1Timer').textContent = '∞';
                document.getElementById('player2Timer').textContent = '∞';
            } else {
                document.getElementById('player1Timer').textContent = formatTime(gameState.player1Time);
                document.getElementById('player2Timer').textContent = formatTime(gameState.player2Time);
            }
        }

        // Start game
        function startGame() {
            const timeLimit = document.getElementById('timeLimit').value;
            const timeLimitSeconds = timeLimit === 'unlimited' ? Infinity : parseInt(timeLimit);
            
            // Clear any existing timer first
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }

            // Reset game state
            gameState = {
                board: initializeBoard(),
                currentPlayer: 'white',
                selectedSquare: null,
                gameStarted: true,
                gameOver: false,
                player1Time: timeLimitSeconds,
                player2Time: timeLimitSeconds,
                timer: null,
                gameMode: document.getElementById('gameMode').value,
                difficulty: document.getElementById('difficulty').value,
                isComputerTurn: false,
                moveHistory: [],
                gameStateHistory: [], // Reset undo history
                capturedPieces: { white: [], black: [] },
                castlingRights: {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                },
                kingMoved: { white: false, black: false },
                rookMoved: {
                    white: { kingside: false, queenside: false },
                    black: { kingside: false, queenside: false }
                },
                enPassantTarget: null,
                isInCheck: { white: false, black: false }
            };

            // Update player names
            document.querySelector('#player1Info .player-name').textContent = 'Player 1 ♔';
            document.querySelector('#player2Info .player-name').textContent = 
                gameState.gameMode === 'computer' ? 'AI Computer ♛' : 'Player 2 ♛';

            clearHighlights();
            renderBoard();
            updatePlayerDisplay();
            updateTimerDisplay();
            updateCapturedPieces();
            updateMoveHistory();
            updateUndoButton();
            
            if (timeLimit !== 'unlimited') startTimer();
            updateGameStatus();
            
            document.querySelector('.start-btn').textContent = '🔄 Restart Battle';
            
            const statusElement = document.getElementById('gameStatus');
            statusElement.className = 'game-status';
            statusElement.textContent = '🎯 Game started! White moves first. Good luck! 🎯';
        }

        // Create flying flowers animation
        function createFlyingFlowers() {
            const flowers = ['🌸', '🌺', '🌻', '🌷', '🌹', '💐', '🏵️', '🌼'];
            const flowerCount = 20;
            
            for (let i = 0; i < flowerCount; i++) {
                setTimeout(() => {
                    const flower = document.createElement('div');
                    flower.className = 'flower';
                    flower.textContent = flowers[Math.floor(Math.random() * flowers.length)];
                    flower.style.left = Math.random() * 100 + 'vw';
                    flower.style.animationDelay = Math.random() * 2 + 's';
                    flower.style.animationDuration = (3 + Math.random() * 2) + 's';
                    document.body.appendChild(flower);
                    
                    // Remove flower after animation
                    setTimeout(() => {
                        if (flower.parentNode) {
                            flower.parentNode.removeChild(flower);
                        }
                    }, 5000);
                }, i * 200);
            }
        }

        // Create confetti animation
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#a29bfe', '#fd79a8'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.animationDelay = Math.random() * 1 + 's';
                    confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
                    document.body.appendChild(confetti);
                    
                    // Remove confetti after animation
                    setTimeout(() => {
                        if (confetti.parentNode) {
                            confetti.parentNode.removeChild(confetti);
                        }
                    }, 4000);
                }, i * 50);
            }
        }

        // Show victory popup with celebrations
        function showVictoryPopup(winner, gameType) {
            const popup = document.getElementById('victoryPopup');
            const title = document.getElementById('victoryTitle');
            const message = document.getElementById('victoryMessage');
            
            // Set victory message based on game type
            if (gameType === 'checkmate') {
                title.textContent = '🏆 CHECKMATE! 🏆';
                message.textContent = `${winner} achieves victory through superior strategy!`;
            } else if (gameType === 'timeout') {
                title.textContent = '⏰ TIME VICTORY! ⏰';
                message.textContent = `${winner} wins as time runs out for the opponent!`;
            } else if (gameType === 'stalemate') {
                title.textContent = '🤝 STALEMATE! 🤝';
                message.textContent = 'An honorable draw - both players fought valiantly!';
            }
            
            // Show popup with animation
            popup.classList.add('show');
            
            // Start celebration animations
            createFlyingFlowers();
            createConfetti();
            
            // Add extra sparkle effects
            setTimeout(() => createConfetti(), 1000);
            setTimeout(() => createFlyingFlowers(), 1500);
        }

        // Close victory popup
        function closeVictoryPopup() {
            const popup = document.getElementById('victoryPopup');
            popup.classList.remove('show');
        }

        // End game with celebration
        function endGame(message, type) {
            gameState.gameOver = true;
            gameState.gameStarted = false;
            gameState.isComputerTurn = false;
            
            // Clear timer
            if (gameState.timer) {
                clearInterval(gameState.timer);
                gameState.timer = null;
            }
            
            const statusElement = document.getElementById('gameStatus');
            statusElement.textContent = message;
            statusElement.className = `game-status ${type}`;
            
            document.querySelectorAll('.player-section').forEach(panel => {
                panel.classList.remove('active');
            });
            
            document.getElementById('thinkingIndicator').classList.remove('show');
            clearHighlights();
            
            // Extract winner from message and show victory popup
            let winner = 'Player';
            if (message.includes('White wins') || message.includes('White')) {
                winner = gameState.gameMode === 'computer' ? 'You' : 'White Player';
            } else if (message.includes('Black wins') || message.includes('Black')) {
                winner = gameState.gameMode === 'computer' ? 'AI Computer' : 'Black Player';
            } else if (message.includes('draw') || message.includes('STALEMATE')) {
                winner = 'Draw';
            }
            
            // Show victory popup after a short delay
            setTimeout(() => {
                showVictoryPopup(winner, type);
            }, 1000);
        }

        // Update game mode display
        function updateGameModeDisplay() {
            const gameMode = document.getElementById('gameMode').value;
            const difficultyControl = document.getElementById('difficultyControl');
            
            if (gameMode === 'computer') {
                difficultyControl.style.display = 'flex';
            } else {
                difficultyControl.style.display = 'none';
            }
        }

        // Advanced Features Functions

        // Update material count
        function updateMaterialCount() {
            let whiteMaterial = 0, blackMaterial = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        const value = pieceValues[piece.piece];
                        if (piece.color === 'white') {
                            whiteMaterial += value;
                        } else {
                            blackMaterial += value;
                        }
                    }
                }
            }
            
            document.getElementById('player1Material').textContent = whiteMaterial;
            document.getElementById('player2Material').textContent = blackMaterial;
        }

        // Update player statistics
        function updatePlayerStats() {
            const stats1 = gameState.playerStats.player1;
            const stats2 = gameState.playerStats.player2;
            
            document.getElementById('player1Rating').textContent = stats1.rating;
            document.getElementById('player1Wins').textContent = stats1.wins;
            document.getElementById('player2Rating').textContent = stats2.rating;
            document.getElementById('player2Wins').textContent = stats2.wins;
        }

        // Show achievement notification
        function showAchievement(achievementId) {
            const achievement = achievements.find(a => a.id === achievementId);
            if (!achievement || gameState.achievements.includes(achievementId)) return;
            
            gameState.achievements.push(achievementId);
            
            const notification = document.getElementById('achievementNotification');
            const icon = notification.querySelector('.achievement-icon');
            const title = notification.querySelector('.achievement-title');
            const description = notification.querySelector('.achievement-description');
            
            icon.textContent = achievement.icon;
            title.textContent = achievement.name;
            description.textContent = achievement.description;
            
            notification.classList.add('show');
            
            // Play achievement sound (visual feedback only)
            if (gameState.soundEnabled) {
                // Visual sound effect
                document.body.style.animation = 'achievementFlash 0.3s ease-out';
                setTimeout(() => {
                    document.body.style.animation = '';
                }, 300);
            }
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }

        // Check for achievements
        function checkAchievements(gameResult) {
            if (gameResult === 'win') {
                const totalWins = gameState.playerStats.player1.wins + gameState.playerStats.player2.wins;
                if (totalWins === 1) {
                    showAchievement('first_win');
                }
                
                if (gameState.moveHistory.length <= 20) {
                    showAchievement('tactician');
                }
                
                const timeLimit = document.getElementById('timeLimit').value;
                if (timeLimit === '60') {
                    showAchievement('speed_demon');
                }
            }
            
            if (gameState.puzzlesSolved >= 10) {
                showAchievement('puzzle_master');
            }
        }

        // Apply board theme
        function applyBoardTheme() {
            const board = document.getElementById('chessBoard');
            const theme = document.getElementById('boardTheme').value;
            
            // Remove all theme classes
            board.classList.remove('classic', 'neon', 'wood', 'marble', 'space', 'ocean');
            
            // Add selected theme
            if (theme !== 'classic') {
                board.classList.add(theme);
            }
            
            gameState.boardTheme = theme;
        }

        // Show hint
        function showHint() {
            if (gameState.gameOver || !gameState.gameStarted || gameState.hintUsed) return;
            
            const moves = getAllPossibleMoves(gameState.currentPlayer);
            if (moves.length === 0) return;
            
            // Get best move for current player
            let bestMove = null;
            let bestValue = gameState.currentPlayer === 'white' ? -Infinity : Infinity;
            
            for (const move of moves) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                // Make move
                const capturedPiece = gameState.board[toRow][toCol];
                const originalEnPassant = gameState.enPassantTarget;
                gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                gameState.board[fromRow][fromCol] = null;

                const moveValue = minimax(2, gameState.currentPlayer === 'black');
                
                // Undo move
                gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                gameState.board[toRow][toCol] = capturedPiece;
                gameState.enPassantTarget = originalEnPassant;

                if ((gameState.currentPlayer === 'white' && moveValue > bestValue) ||
                    (gameState.currentPlayer === 'black' && moveValue < bestValue)) {
                    bestValue = moveValue;
                    bestMove = move;
                }
            }
            
            if (bestMove) {
                const [fromRow, fromCol] = bestMove.from;
                const [toRow, toCol] = bestMove.to;
                
                // Highlight hint squares
                const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
                const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
                
                fromSquare.style.boxShadow = '0 0 20px #ffd700, inset 0 0 20px rgba(255, 215, 0, 0.3)';
                toSquare.style.boxShadow = '0 0 20px #ffd700, inset 0 0 20px rgba(255, 215, 0, 0.3)';
                
                setTimeout(() => {
                    fromSquare.style.boxShadow = '';
                    toSquare.style.boxShadow = '';
                }, 3000);
                
                gameState.hintUsed = true;
                document.getElementById('hintBtn').disabled = true;
                document.getElementById('hintBtn').textContent = '💡 Used';
            }
        }

        // Load puzzle
        function loadPuzzle(puzzleId) {
            const puzzle = chessPuzzles.find(p => p.id === puzzleId) || chessPuzzles[0];
            gameState.currentPuzzle = puzzle;
            
            // Set puzzle info
            document.getElementById('puzzleDifficulty').textContent = puzzle.difficulty;
            document.getElementById('puzzleRating').textContent = puzzle.rating;
            document.getElementById('puzzleObjective').textContent = puzzle.objective;
            
            // Reset game state for puzzle
            gameState.board = initializeBoard();
            gameState.currentPlayer = 'white';
            gameState.gameStarted = true;
            gameState.gameOver = false;
            gameState.selectedSquare = null;
            gameState.capturedPieces = { white: [], black: [] };
            gameState.moveHistory = [];
            gameState.gameStateHistory = [];
            gameState.isInCheck = { white: false, black: false };
            
            // Clear any existing timer
            if (gameState.timer) {
                clearInterval(gameState.timer);
                gameState.timer = null;
            }
            
            // Update all displays
            clearHighlights();
            renderBoard();
            updatePlayerDisplay();
            updateCapturedPieces();
            updateMoveHistory();
            updateUndoButton();
            updateMaterialCount();
            
            // Update game status for puzzle mode
            const statusElement = document.getElementById('gameStatus');
            statusElement.textContent = `🧩 Puzzle ${puzzle.id}: ${puzzle.objective} 🧩`;
            statusElement.className = 'game-status';
            
            // Update timer display for puzzle mode
            document.getElementById('player1Timer').textContent = '∞';
            document.getElementById('player2Timer').textContent = '∞';
        }

        // Next puzzle
        function nextPuzzle() {
            const currentId = gameState.currentPuzzle ? gameState.currentPuzzle.id : 0;
            const nextId = (currentId % chessPuzzles.length) + 1;
            loadPuzzle(nextId);
        }

        // Solve puzzle
        function solvePuzzle() {
            if (!gameState.currentPuzzle) return;
            
            const solution = gameState.currentPuzzle.solution;
            const statusElement = document.getElementById('gameStatus');
            statusElement.textContent = `💡 Solution: ${solution} - ${gameState.currentPuzzle.description}`;
            statusElement.className = 'game-status';
            
            // Highlight the solution move if possible
            showHint();
        }

        // Reset puzzle
        function resetPuzzle() {
            if (!gameState.currentPuzzle) return;
            loadPuzzle(gameState.currentPuzzle.id);
        }

        // Update AI analysis
        function updateAIAnalysis() {
            if (gameState.gameMode !== 'computer' || !gameState.analysisMode) return;
            
            const evaluation = evaluateBoard();
            const analysisBar = document.getElementById('analysisFill');
            const analysisText = document.getElementById('analysisText');
            const bestMoveElement = document.getElementById('bestMove');
            
            // Convert evaluation to percentage (50% = equal)
            const percentage = Math.max(0, Math.min(100, 50 + (evaluation * 5)));
            analysisBar.style.width = percentage + '%';
            
            if (evaluation > 2) {
                analysisText.textContent = 'Black Winning';
            } else if (evaluation > 0.5) {
                analysisText.textContent = 'Black Better';
            } else if (evaluation < -2) {
                analysisText.textContent = 'White Winning';
            } else if (evaluation < -0.5) {
                analysisText.textContent = 'White Better';
            } else {
                analysisText.textContent = 'Equal';
            }
            
            // Show best move
            const bestMove = calculateAIMove();
            if (bestMove) {
                const [fromRow, fromCol] = bestMove.from;
                const [toRow, toCol] = bestMove.to;
                const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                bestMoveElement.textContent = `Best: ${fromSquare}-${toSquare}`;
            }
        }

        // Enhanced difficulty settings
        function getAIDifficulty() {
            const difficultySettings = {
                'beginner': { depth: 1, randomness: 0.6, rating: 800 },
                'easy': { depth: 2, randomness: 0.4, rating: 1200 },
                'medium': { depth: 3, randomness: 0.2, rating: 1600 },
                'hard': { depth: 4, randomness: 0.1, rating: 2000 },
                'expert': { depth: 5, randomness: 0.05, rating: 2400 },
                'grandmaster': { depth: 6, randomness: 0, rating: 2800 }
            };
            
            return difficultySettings[gameState.difficulty] || difficultySettings['medium'];
        }



        // Enhanced end game with statistics update
        function endGameAdvanced(message, type, winner) {
            endGame(message, type);
            
            // Update statistics
            if (winner === 'white') {
                gameState.playerStats.player1.wins++;
                gameState.playerStats.player2.losses++;
                checkAchievements('win');
            } else if (winner === 'black') {
                gameState.playerStats.player2.wins++;
                gameState.playerStats.player1.losses++;
                checkAchievements('win');
            } else {
                gameState.playerStats.player1.draws++;
                gameState.playerStats.player2.draws++;
            }
            
            updatePlayerStats();
        }

        // Update sound setting
        function updateSoundSetting() {
            const soundValue = document.getElementById('soundEffects').value;
            gameState.soundEnabled = soundValue === 'on';
        }

        // Event listeners (removed since we're using inline handlers now)

        // Initialize the game
        gameState.board = initializeBoard();
        renderBoard();
        updateTimerDisplay();
        updateGameModeDisplay();
        updateCapturedPieces();
        updateMoveHistory();
        updateUndoButton();
        updatePlayerStats();
        updateMaterialCount();
        applyBoardTheme();
        
        // Ensure difficulty control is properly shown/hidden on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateGameModeDisplay();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'966d443d95f7937f',t:'MTc1Mzc5ODkyNy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Chess Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 226, 0.2) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundFloat 20s ease-in-out infinite;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.7; }
            33% { transform: scale(1.1) rotate(1deg); opacity: 0.8; }
            66% { transform: scale(0.9) rotate(-1deg); opacity: 0.6; }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 25px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            animation: headerGlow 3s ease-in-out infinite;
        }

        @keyframes headerGlow {
            0%, 100% { box-shadow: 0 20px 40px rgba(0,0,0,0.1), 0 0 30px rgba(102, 126, 234, 0.2); }
            50% { box-shadow: 0 25px 50px rgba(0,0,0,0.15), 0 0 40px rgba(102, 126, 234, 0.4); }
        }

        .title {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbowText 4s ease-in-out infinite;
            text-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        @keyframes rainbowText {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(78, 205, 196, 0.1));
            padding: 12px 20px;
            border-radius: 20px;
            border: 2px solid transparent;
            background-clip: padding-box;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .control-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .control-group:hover::before {
            left: 100%;
        }

        .control-group:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            border-color: #4ecdc4;
        }

        .control-group label {
            font-weight: 700;
            color: #2c3e50;
            font-size: 0.95rem;
        }

        .control-group select, .start-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .start-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-btn:hover, .control-group select:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            flex-wrap: wrap;
            max-width: 1400px;
            margin: 0 auto;
        }

        .player-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            padding: 25px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            min-width: 250px;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .player-section::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            animation: rotate 4s linear infinite;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .player-section.active::before {
            opacity: 1;
        }

        @keyframes rotate {
            100% { transform: rotate(360deg); }
        }

        .player-section.active {
            transform: scale(1.05);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.3);
            border-color: #4ecdc4;
        }

        .player-name {
            font-size: 1.5rem;
            font-weight: 800;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
            position: relative;
            z-index: 2;
        }

        .player-timer {
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 2;
        }

        .captured-pieces {
            margin-top: 20px;
            position: relative;
            z-index: 2;
        }

        .captured-pieces h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .captured-piece {
            font-size: 1.5rem;
            opacity: 0.7;
            animation: captureFloat 2s ease-in-out infinite;
        }

        @keyframes captureFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }

        .chess-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .board-coordinates {
            display: flex;
            justify-content: space-between;
            width: 640px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 16px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 80px);
            grid-template-rows: repeat(8, 80px);
            border: 6px solid #8b4513;
            border-radius: 15px;
            background: linear-gradient(135deg, #8b4513, #a0522d);
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .chess-board::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 400% 400%;
            animation: borderGlow 3s ease-in-out infinite;
            border-radius: 15px;
            z-index: -1;
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .chess-square {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5rem;
            cursor: pointer;
            position: relative;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
        }

        .chess-square.light {
            background: linear-gradient(135deg, #f0d9b5, #f5deb3);
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #b58863, #8b4513);
        }

        .chess-square:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .chess-square.selected {
            background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
            transform: scale(1.15);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
            animation: selectedPulse 1.5s ease-in-out infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { 
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 215, 0, 1), inset 0 0 30px rgba(255, 255, 255, 0.5);
            }
        }

        .chess-square.legal-move {
            background: linear-gradient(135deg, #00ff88, #00cc6a) !important;
            animation: legalMoveGlow 2s ease-in-out infinite;
        }

        @keyframes legalMoveGlow {
            0%, 100% { 
                box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
            }
            50% { 
                box-shadow: 0 0 25px rgba(0, 255, 136, 0.9);
            }
        }

        .chess-square.legal-move::after {
            content: '●';
            position: absolute;
            font-size: 2rem;
            color: #006400;
            animation: moveIndicator 1.5s ease-in-out infinite;
        }

        .chess-square.legal-move.has-piece::after {
            content: '⚔';
            font-size: 2.5rem;
            color: #dc143c;
        }

        @keyframes moveIndicator {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .chess-square.in-check {
            background: linear-gradient(135deg, #ff4757, #ff3838) !important;
            animation: checkWarning 1s ease-in-out infinite;
        }

        @keyframes checkWarning {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 71, 87, 0.8);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 30px rgba(255, 71, 87, 1);
                transform: scale(1.05);
            }
        }

        .chess-square.castle-move {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7) !important;
            animation: castleGlow 2s ease-in-out infinite;
        }

        @keyframes castleGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(162, 155, 254, 0.6); }
            50% { box-shadow: 0 0 25px rgba(162, 155, 254, 0.9); }
        }

        .chess-square.castle-move::after {
            content: '🏰';
            position: absolute;
            font-size: 1.5rem;
            animation: castleIndicator 1.5s ease-in-out infinite;
        }

        @keyframes castleIndicator {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .piece {
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            position: relative;
            z-index: 2;
            animation: pieceFloat 3s ease-in-out infinite;
        }

        @keyframes pieceFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-2px); }
        }

        .piece.white {
            color: #ffffff;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.8), 0 0 10px rgba(255,255,255,0.5);
        }

        .piece.black {
            color: #2c3e50;
            text-shadow: 2px 2px 6px rgba(255,255,255,0.3), 0 0 10px rgba(44,62,80,0.7);
        }

        .piece:hover {
            transform: scale(1.2) translateY(-5px);
            filter: drop-shadow(5px 5px 15px rgba(0,0,0,0.6));
        }

        .piece.moving {
            animation: pieceMove 0.5s ease-in-out;
            z-index: 100;
        }

        @keyframes pieceMove {
            0% { transform: scale(1); }
            50% { transform: scale(1.3) translateY(-10px); }
            100% { transform: scale(1); }
        }

        .game-status {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-top: 20px;
            text-align: center;
            color: #2c3e50;
            font-size: 1.3rem;
            font-weight: 700;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.5s ease;
        }

        .game-status.check {
            background: linear-gradient(135deg, #ff4757, #ff3838);
            color: white;
            animation: checkAlert 1s ease-in-out infinite;
        }

        @keyframes checkAlert {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .game-status.checkmate {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #2c3e50;
            animation: victoryDance 2s ease-in-out infinite;
        }

        @keyframes victoryDance {
            0%, 100% { transform: scale(1) rotateZ(0deg); }
            25% { transform: scale(1.1) rotateZ(2deg); }
            75% { transform: scale(1.1) rotateZ(-2deg); }
        }

        .thinking-indicator {
            display: none;
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            padding: 12px 20px;
            border-radius: 15px;
            font-weight: 600;
            margin-top: 15px;
            animation: thinking 1.5s ease-in-out infinite;
            position: relative;
            z-index: 2;
        }

        .thinking-indicator.show {
            display: block;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .move-history {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            position: relative;
            z-index: 2;
        }

        .move-history h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .move-item {
            padding: 5px 10px;
            margin: 2px 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(78, 205, 196, 0.1));
            border-radius: 8px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .move-item:hover {
            transform: translateX(5px);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(78, 205, 196, 0.2));
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .player-section {
                max-width: 600px;
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .chess-board {
                grid-template-columns: repeat(8, 60px);
                grid-template-rows: repeat(8, 60px);
            }
            
            .chess-square {
                width: 60px;
                height: 60px;
                font-size: 2.5rem;
            }
            
            .board-coordinates {
                width: 480px;
            }
            
            .title {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            .chess-board {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }
            
            .chess-square {
                width: 45px;
                height: 45px;
                font-size: 2rem;
            }
            
            .board-coordinates {
                width: 360px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">♔ PROFESSIONAL CHESS ARENA ♛</h1>
        <div class="controls">
            <div class="control-group">
                <label for="gameMode">🎮 Game Mode:</label>
                <select id="gameMode">
                    <option value="2player">2 Players</option>
                    <option value="computer">vs Computer</option>
                </select>
            </div>
            <div class="control-group" id="difficultyControl" style="display: none;">
                <label for="difficulty">🧠 AI Difficulty:</label>
                <select id="difficulty">
                    <option value="easy">Easy</option>
                    <option value="medium">Medium</option>
                    <option value="hard">Hard</option>
                    <option value="expert">Expert</option>
                </select>
            </div>
            <div class="control-group">
                <label for="timeLimit">⏱️ Time Control:</label>
                <select id="timeLimit">
                    <option value="60">1 Minute</option>
                    <option value="300" selected>5 Minutes</option>
                    <option value="600">10 Minutes</option>
                    <option value="unlimited">Unlimited</option>
                </select>
            </div>
            <button class="start-btn" onclick="startGame()">🚀 Start Battle</button>
        </div>
    </div>

    <div class="game-container">
        <div class="player-section" id="player1Info">
            <div class="player-name">Player 1 ♔</div>
            <div class="player-timer" id="player1Timer">5:00</div>
            <div class="captured-pieces">
                <h4>Captured Pieces:</h4>
                <div class="captured-list" id="player1Captured"></div>
            </div>
            <div class="move-history">
                <h4>Move History:</h4>
                <div id="moveHistory"></div>
            </div>
        </div>

        <div class="chess-board-container">
            <div class="board-coordinates">
                <span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span>
            </div>
            <div class="chess-board" id="chessBoard"></div>
        </div>

        <div class="player-section" id="player2Info">
            <div class="player-name">Player 2 ♛</div>
            <div class="player-timer" id="player2Timer">5:00</div>
            <div class="captured-pieces">
                <h4>Captured Pieces:</h4>
                <div class="captured-list" id="player2Captured"></div>
            </div>
            <div class="thinking-indicator" id="thinkingIndicator">
                🤖 AI is calculating the perfect move...
            </div>
        </div>
    </div>

    <div class="game-status" id="gameStatus">🎯 Configure your game settings and click "Start Battle" to begin the ultimate chess experience! 🎯</div>

    <script>
        // Chess pieces using Unicode symbols
        const pieces = {
            'white': {
                'king': '♔', 'queen': '♕', 'rook': '♖', 
                'bishop': '♗', 'knight': '♘', 'pawn': '♙'
            },
            'black': {
                'king': '♚', 'queen': '♛', 'rook': '♜', 
                'bishop': '♝', 'knight': '♞', 'pawn': '♟'
            }
        };

        // Piece values for AI evaluation
        const pieceValues = {
            'pawn': 1, 'knight': 3, 'bishop': 3, 
            'rook': 5, 'queen': 9, 'king': 1000
        };

        // Game state
        let gameState = {
            board: [],
            currentPlayer: 'white',
            selectedSquare: null,
            gameStarted: false,
            gameOver: false,
            player1Time: 300,
            player2Time: 300,
            timer: null,
            gameMode: '2player',
            difficulty: 'medium',
            isComputerTurn: false,
            moveHistory: [],
            capturedPieces: { white: [], black: [] },
            castlingRights: {
                white: { kingside: true, queenside: true },
                black: { kingside: true, queenside: true }
            },
            kingMoved: { white: false, black: false },
            rookMoved: {
                white: { kingside: false, queenside: false },
                black: { kingside: false, queenside: false }
            },
            enPassantTarget: null,
            isInCheck: { white: false, black: false }
        };

        // Initialize the chess board
        function initializeBoard() {
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            const initialSetup = [
                ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],
                ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn']
            ];

            // Black pieces
            for (let col = 0; col < 8; col++) {
                board[0][col] = { color: 'black', piece: initialSetup[0][col] };
                board[1][col] = { color: 'black', piece: initialSetup[1][col] };
            }

            // White pieces
            for (let col = 0; col < 8; col++) {
                board[7][col] = { color: 'white', piece: initialSetup[0][col] };
                board[6][col] = { color: 'white', piece: initialSetup[1][col] };
            }

            return board;
        }

        // Render the chess board
        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'chess-square';
                    square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Highlight king if in check
                    const piece = gameState.board[row][col];
                    if (piece && piece.piece === 'king' && gameState.isInCheck[piece.color]) {
                        square.classList.add('in-check');
                    }

                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = `piece ${piece.color}`;
                        pieceElement.textContent = pieces[piece.color][piece.piece];
                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
        }

        // Handle square clicks
        function handleSquareClick(row, col) {
            if (!gameState.gameStarted || gameState.gameOver || gameState.isComputerTurn) return;

            const square = gameState.board[row][col];

            // Clear previous selections and highlights
            clearHighlights();

            if (gameState.selectedSquare) {
                const [selectedRow, selectedCol] = gameState.selectedSquare;
                
                if (row === selectedRow && col === selectedCol) {
                    gameState.selectedSquare = null;
                    return;
                }

                // Try to move piece
                if (isValidMove(selectedRow, selectedCol, row, col)) {
                    const moveResult = movePiece(selectedRow, selectedCol, row, col);
                    if (moveResult) {
                        gameState.selectedSquare = null;
                        switchPlayer();
                        return;
                    }
                }
            }

            // Select piece if it belongs to current player
            if (square && square.color === gameState.currentPlayer) {
                gameState.selectedSquare = [row, col];
                highlightSelectedSquare(row, col);
                highlightLegalMoves(row, col);
            }
        }

        // Clear all highlights
        function clearHighlights() {
            document.querySelectorAll('.chess-square').forEach(sq => {
                sq.classList.remove('selected', 'legal-move', 'has-piece', 'castle-move');
            });
        }

        // Highlight selected square
        function highlightSelectedSquare(row, col) {
            const squareElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            squareElement.classList.add('selected');
        }

        // Highlight all legal moves for selected piece
        function highlightLegalMoves(row, col) {
            const legalMoves = getValidMoves(row, col);
            legalMoves.forEach(([r, c, moveType]) => {
                const squareElement = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                
                if (moveType === 'castle') {
                    squareElement.classList.add('castle-move');
                } else {
                    squareElement.classList.add('legal-move');
                    if (gameState.board[r][c]) {
                        squareElement.classList.add('has-piece');
                    }
                }
            });
        }

        // Check if a square is under attack by the opponent
        function isSquareUnderAttack(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = gameState.board[r][c];
                    if (piece && piece.color === byColor) {
                        if (canPieceAttackSquare(r, c, row, col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Check if a piece can attack a specific square
        function canPieceAttackSquare(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            if (!piece) return false;

            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch (piece.piece) {
                case 'pawn':
                    const direction = piece.color === 'white' ? -1 : 1;
                    return Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction;

                case 'rook':
                    return (fromRow === toRow || fromCol === toCol) && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'bishop':
                    return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'queen':
                    return ((fromRow === toRow || fromCol === toCol) || rowDiff === colDiff) && 
                           isPathClear(fromRow, fromCol, toRow, toCol);

                case 'king':
                    return rowDiff <= 1 && colDiff <= 1;

                case 'knight':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                default:
                    return false;
            }
        }

        // Find king position
        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color && piece.piece === 'king') {
                        return [row, col];
                    }
                }
            }
            return null;
        }

        // Check if king is in check
        function isKingInCheck(color) {
            const kingPos = findKing(color);
            if (!kingPos) return false;
            
            const [kingRow, kingCol] = kingPos;
            const opponentColor = color === 'white' ? 'black' : 'white';
            return isSquareUnderAttack(kingRow, kingCol, opponentColor);
        }

        // Check if move would leave king in check
        function wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // Make temporary move
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            const inCheck = isKingInCheck(piece.color);
            
            // Undo temporary move
            gameState.board[fromRow][fromCol] = piece;
            gameState.board[toRow][toCol] = capturedPiece;
            
            return inCheck;
        }

        // Enhanced move validation with all chess rules
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 ||
                toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;

            const piece = gameState.board[fromRow][fromCol];
            const targetSquare = gameState.board[toRow][toCol];

            if (!piece) return false;
            if (targetSquare && targetSquare.color === piece.color) return false;

            // Check basic piece movement rules
            if (!isBasicMoveValid(fromRow, fromCol, toRow, toCol)) return false;

            // Check if move would leave king in check
            if (wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol)) return false;

            return true;
        }

        // Basic piece movement validation
        function isBasicMoveValid(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const targetSquare = gameState.board[toRow][toCol];
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch (piece.piece) {
                case 'pawn':
                    const direction = piece.color === 'white' ? -1 : 1;
                    const startRow = piece.color === 'white' ? 6 : 1;
                    
                    // Forward move
                    if (fromCol === toCol && !targetSquare) {
                        return (toRow === fromRow + direction) || 
                               (fromRow === startRow && toRow === fromRow + 2 * direction);
                    }
                    // Diagonal capture
                    if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {
                        return targetSquare || isEnPassantCapture(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'rook':
                    return (fromRow === toRow || fromCol === toCol) && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'bishop':
                    return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'queen':
                    return ((fromRow === toRow || fromCol === toCol) || rowDiff === colDiff) && 
                           isPathClear(fromRow, fromCol, toRow, toCol);

                case 'king':
                    // Normal king move
                    if (rowDiff <= 1 && colDiff <= 1) return true;
                    
                    // Castling
                    if (rowDiff === 0 && colDiff === 2) {
                        return canCastle(piece.color, toCol > fromCol ? 'kingside' : 'queenside');
                    }
                    return false;

                case 'knight':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                default:
                    return false;
            }
        }

        // Check if path is clear
        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                if (gameState.board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }

            return true;
        }

        // Check if castling is possible
        function canCastle(color, side) {
            if (gameState.kingMoved[color]) return false;
            if (gameState.rookMoved[color][side]) return false;
            if (isKingInCheck(color)) return false;

            const row = color === 'white' ? 7 : 0;
            const kingCol = 4;
            const rookCol = side === 'kingside' ? 7 : 0;
            const direction = side === 'kingside' ? 1 : -1;

            // Check if squares between king and rook are empty
            for (let col = kingCol + direction; col !== rookCol; col += direction) {
                if (gameState.board[row][col]) return false;
            }

            // Check if king passes through or ends up in check
            const opponentColor = color === 'white' ? 'black' : 'white';
            for (let i = 0; i <= 2; i++) {
                const checkCol = kingCol + (i * direction);
                if (isSquareUnderAttack(row, checkCol, opponentColor)) return false;
            }

            return true;
        }

        // Check if move is en passant capture
        function isEnPassantCapture(fromRow, fromCol, toRow, toCol) {
            if (!gameState.enPassantTarget) return false;
            const [targetRow, targetCol] = gameState.enPassantTarget;
            return toRow === targetRow && toCol === targetCol;
        }

        // Get all valid moves for a piece
        function getValidMoves(row, col) {
            const moves = [];
            const piece = gameState.board[row][col];
            
            if (!piece) return moves;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        // Check if it's a castling move
                        if (piece.piece === 'king' && Math.abs(c - col) === 2) {
                            moves.push([r, c, 'castle']);
                        } else {
                            moves.push([r, c, 'normal']);
                        }
                    }
                }
            }
            return moves;
        }

        // Get all possible moves for a color
        function getAllPossibleMoves(color) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color) {
                        const validMoves = getValidMoves(row, col);
                        validMoves.forEach(move => {
                            moves.push({
                                from: [row, col],
                                to: [move[0], move[1]],
                                piece: piece,
                                moveType: move[2] || 'normal'
                            });
                        });
                    }
                }
            }
            return moves;
        }

        // Check for checkmate or stalemate
        function isCheckmate(color) {
            if (!isKingInCheck(color)) return false;
            return getAllPossibleMoves(color).length === 0;
        }

        function isStalemate(color) {
            if (isKingInCheck(color)) return false;
            return getAllPossibleMoves(color).length === 0;
        }

        // Move piece with all special rules
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // Handle castling
            if (piece.piece === 'king' && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const row = fromRow;
                
                // Move rook
                gameState.board[row][rookToCol] = gameState.board[row][rookFromCol];
                gameState.board[row][rookFromCol] = null;
                
                gameState.kingMoved[piece.color] = true;
                gameState.rookMoved[piece.color][isKingside ? 'kingside' : 'queenside'] = true;
            }

            // Handle en passant capture
            if (piece.piece === 'pawn' && isEnPassantCapture(fromRow, fromCol, toRow, toCol)) {
                const captureRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                const capturedPawn = gameState.board[captureRow][toCol];
                gameState.capturedPieces[capturedPawn.color].push(capturedPawn);
                gameState.board[captureRow][toCol] = null;
            }

            // Set en passant target for next move
            gameState.enPassantTarget = null;
            if (piece.piece === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                gameState.enPassantTarget = [fromRow + (toRow - fromRow) / 2, fromCol];
            }

            // Handle regular capture
            if (capturedPiece) {
                gameState.capturedPieces[capturedPiece.color].push(capturedPiece);
            }

            // Move the piece
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;

            // Update castling rights
            if (piece.piece === 'king') {
                gameState.kingMoved[piece.color] = true;
            }
            if (piece.piece === 'rook') {
                if (fromCol === 0) gameState.rookMoved[piece.color].queenside = true;
                if (fromCol === 7) gameState.rookMoved[piece.color].kingside = true;
            }

            // Handle pawn promotion
            if (piece.piece === 'pawn' && (toRow === 0 || toRow === 7)) {
                gameState.board[toRow][toCol] = { color: piece.color, piece: 'queen' };
            }

            // Add move to history
            const moveNotation = `${pieces[piece.color][piece.piece]} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} → ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            gameState.moveHistory.push(moveNotation);

            // Add piece animation
            const pieceElement = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"] .piece`);
            if (pieceElement) {
                pieceElement.classList.add('moving');
                setTimeout(() => pieceElement.classList.remove('moving'), 500);
            }

            renderBoard();
            updateCapturedPieces();
            updateMoveHistory();
            
            return true;
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            const player1Captured = document.getElementById('player1Captured');
            const player2Captured = document.getElementById('player2Captured');
            
            player1Captured.innerHTML = gameState.capturedPieces.black.map(piece => 
                `<span class="captured-piece">${pieces.black[piece.piece]}</span>`
            ).join('');
            
            player2Captured.innerHTML = gameState.capturedPieces.white.map(piece => 
                `<span class="captured-piece">${pieces.white[piece.piece]}</span>`
            ).join('');
        }

        // Update move history display
        function updateMoveHistory() {
            const historyElement = document.getElementById('moveHistory');
            historyElement.innerHTML = gameState.moveHistory.slice(-10).map((move, index) => 
                `<div class="move-item">${gameState.moveHistory.length - 10 + index + 1}. ${move}</div>`
            ).join('');
            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Switch players
        function switchPlayer() {
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            
            // Update check status
            gameState.isInCheck.white = isKingInCheck('white');
            gameState.isInCheck.black = isKingInCheck('black');
            
            updatePlayerDisplay();
            updateGameStatus();

            // Check for game end conditions
            if (isCheckmate(gameState.currentPlayer)) {
                const winner = gameState.currentPlayer === 'white' ? 'Black' : 'White';
                endGame(`🎉 CHECKMATE! ${winner} wins! 🎉`, 'checkmate');
                return;
            }
            
            if (isStalemate(gameState.currentPlayer)) {
                endGame('🤝 STALEMATE! It\'s a draw! 🤝', 'stalemate');
                return;
            }

            // Trigger AI move if it's computer's turn
            if (gameState.gameMode === 'computer' && gameState.currentPlayer === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }

        // Update player display
        function updatePlayerDisplay() {
            const player1Info = document.getElementById('player1Info');
            const player2Info = document.getElementById('player2Info');

            player1Info.classList.toggle('active', gameState.currentPlayer === 'white');
            player2Info.classList.toggle('active', gameState.currentPlayer === 'black');
        }

        // Update game status
        function updateGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            
            if (!gameState.gameOver && gameState.gameStarted) {
                let statusText;
                let statusClass = '';
                
                if (gameState.isInCheck[gameState.currentPlayer]) {
                    statusText = `⚠️ CHECK! ${gameState.currentPlayer === 'white' ? 'White' : 'Black'} king is in danger! ⚠️`;
                    statusClass = 'check';
                } else if (gameState.gameMode === 'computer') {
                    statusText = gameState.currentPlayer === 'white' ? 
                        "🎯 Your turn - Make your strategic move! 🎯" : 
                        "🤖 AI is analyzing the position... 🤖";
                } else {
                    const currentPlayerName = gameState.currentPlayer === 'white' ? 'White' : 'Black';
                    statusText = `⚡ ${currentPlayerName}'s turn - Plan your next move! ⚡`;
                }
                
                statusElement.textContent = statusText;
                statusElement.className = `game-status ${statusClass}`;
            }
        }

        // AI move calculation (enhanced)
        function evaluateBoard() {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        let value = pieceValues[piece.piece];
                        
                        // Add positional bonuses
                        if (piece.piece === 'pawn') {
                            // Pawns are more valuable when advanced
                            const advancement = piece.color === 'white' ? (6 - row) : (row - 1);
                            value += advancement * 0.1;
                        }
                        
                        if (piece.piece === 'knight' || piece.piece === 'bishop') {
                            // Knights and bishops are better in center
                            const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);
                            value += (7 - centerDistance) * 0.1;
                        }
                        
                        score += piece.color === 'black' ? value : -value;
                    }
                }
            }
            
            // Add bonus for check
            if (gameState.isInCheck.white) score += 0.5;
            if (gameState.isInCheck.black) score -= 0.5;
            
            return score;
        }

        // Minimax algorithm with alpha-beta pruning
        function minimax(depth, isMaximizing, alpha = -Infinity, beta = Infinity) {
            if (depth === 0) {
                return evaluateBoard();
            }

            const moves = getAllPossibleMoves(isMaximizing ? 'black' : 'white');
            
            if (moves.length === 0) {
                const color = isMaximizing ? 'black' : 'white';
                if (isKingInCheck(color)) {
                    return isMaximizing ? -10000 : 10000; // Checkmate
                } else {
                    return 0; // Stalemate
                }
            }

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const [fromRow, fromCol] = move.from;
                    const [toRow, toCol] = move.to;
                    
                    // Make move
                    const capturedPiece = gameState.board[toRow][toCol];
                    const originalEnPassant = gameState.enPassantTarget;
                    gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                    gameState.board[fromRow][fromCol] = null;

                    const eval = minimax(depth - 1, false, alpha, beta);
                    
                    // Undo move
                    gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                    gameState.board[toRow][toCol] = capturedPiece;
                    gameState.enPassantTarget = originalEnPassant;

                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break; // Alpha-beta pruning
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const [fromRow, fromCol] = move.from;
                    const [toRow, toCol] = move.to;
                    
                    // Make move
                    const capturedPiece = gameState.board[toRow][toCol];
                    const originalEnPassant = gameState.enPassantTarget;
                    gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                    gameState.board[fromRow][fromCol] = null;

                    const eval = minimax(depth - 1, true, alpha, beta);
                    
                    // Undo move
                    gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                    gameState.board[toRow][toCol] = capturedPiece;
                    gameState.enPassantTarget = originalEnPassant;

                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break; // Alpha-beta pruning
                }
                return minEval;
            }
        }

        // Calculate best AI move
        function calculateAIMove() {
            const difficultyDepth = {
                'easy': 1,
                'medium': 2,
                'hard': 3,
                'expert': 4
            };

            const depth = difficultyDepth[gameState.difficulty];
            const moves = getAllPossibleMoves('black');
            
            if (moves.length === 0) return null;

            // Add randomness for easier difficulties
            if (gameState.difficulty === 'easy' && Math.random() < 0.4) {
                return moves[Math.floor(Math.random() * moves.length)];
            }

            let bestMove = null;
            let bestValue = -Infinity;

            for (const move of moves) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                // Make move
                const capturedPiece = gameState.board[toRow][toCol];
                const originalEnPassant = gameState.enPassantTarget;
                gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                gameState.board[fromRow][fromCol] = null;

                const moveValue = minimax(depth - 1, false);
                
                // Undo move
                gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                gameState.board[toRow][toCol] = capturedPiece;
                gameState.enPassantTarget = originalEnPassant;

                if (moveValue > bestValue) {
                    bestValue = moveValue;
                    bestMove = move;
                }
            }

            return bestMove;
        }

        // Execute AI move
        function makeAIMove() {
            if (gameState.gameMode !== 'computer' || gameState.currentPlayer !== 'black') return;

            gameState.isComputerTurn = true;
            document.getElementById('thinkingIndicator').classList.add('show');

            setTimeout(() => {
                const aiMove = calculateAIMove();
                if (aiMove) {
                    const [fromRow, fromCol] = aiMove.from;
                    const [toRow, toCol] = aiMove.to;
                    movePiece(fromRow, fromCol, toRow, toCol);
                    switchPlayer();
                }
                
                document.getElementById('thinkingIndicator').classList.remove('show');
                gameState.isComputerTurn = false;
            }, Math.random() * 1500 + 1000);
        }

        // Timer functions
        function startTimer() {
            const timeLimit = document.getElementById('timeLimit').value;
            if (timeLimit === 'unlimited') return;

            gameState.timer = setInterval(() => {
                if (gameState.currentPlayer === 'white') {
                    gameState.player1Time--;
                    if (gameState.player1Time <= 0) {
                        endGame('⏰ Time\'s up! Black wins by timeout! ⏰', 'timeout');
                        return;
                    }
                } else {
                    gameState.player2Time--;
                    if (gameState.player2Time <= 0) {
                        endGame('⏰ Time\'s up! White wins by timeout! ⏰', 'timeout');
                        return;
                    }
                }
                updateTimerDisplay();
            }, 1000);
        }

        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                if (seconds < 0) return "0:00";
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const timeLimit = document.getElementById('timeLimit').value;
            if (timeLimit === 'unlimited') {
                document.getElementById('player1Timer').textContent = '∞';
                document.getElementById('player2Timer').textContent = '∞';
            } else {
                document.getElementById('player1Timer').textContent = formatTime(gameState.player1Time);
                document.getElementById('player2Timer').textContent = formatTime(gameState.player2Time);
            }
        }

        // Start game
        function startGame() {
            const timeLimit = document.getElementById('timeLimit').value;
            const timeLimitSeconds = timeLimit === 'unlimited' ? Infinity : parseInt(timeLimit);
            
            // Reset game state
            gameState = {
                board: initializeBoard(),
                currentPlayer: 'white',
                selectedSquare: null,
                gameStarted: true,
                gameOver: false,
                player1Time: timeLimitSeconds,
                player2Time: timeLimitSeconds,
                timer: null,
                gameMode: document.getElementById('gameMode').value,
                difficulty: document.getElementById('difficulty').value,
                isComputerTurn: false,
                moveHistory: [],
                capturedPieces: { white: [], black: [] },
                castlingRights: {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                },
                kingMoved: { white: false, black: false },
                rookMoved: {
                    white: { kingside: false, queenside: false },
                    black: { kingside: false, queenside: false }
                },
                enPassantTarget: null,
                isInCheck: { white: false, black: false }
            };

            // Update player names
            document.querySelector('#player1Info .player-name').textContent = 'Player 1 ♔';
            document.querySelector('#player2Info .player-name').textContent = 
                gameState.gameMode === 'computer' ? 'AI Computer ♛' : 'Player 2 ♛';

            clearHighlights();
            renderBoard();
            updatePlayerDisplay();
            updateTimerDisplay();
            updateCapturedPieces();
            updateMoveHistory();
            
            if (timeLimit !== 'unlimited') startTimer();
            updateGameStatus();
            
            document.querySelector('.start-btn').textContent = '🔄 Restart Battle';
            
            const statusElement = document.getElementById('gameStatus');
            statusElement.className = 'game-status';
            statusElement.textContent = '🎯 Game started! White moves first. Good luck! 🎯';
        }

        // End game
        function endGame(message, type) {
            gameState.gameOver = true;
            gameState.gameStarted = false;
            gameState.isComputerTurn = false;
            clearInterval(gameState.timer);
            
            const statusElement = document.getElementById('gameStatus');
            statusElement.textContent = message;
            statusElement.className = `game-status ${type}`;
            
            document.querySelectorAll('.player-section').forEach(panel => {
                panel.classList.remove('active');
            });
            
            document.getElementById('thinkingIndicator').classList.remove('show');
            clearHighlights();
        }

        // Update game mode display
        function updateGameModeDisplay() {
            const gameMode = document.getElementById('gameMode').value;
            const difficultyControl = document.getElementById('difficultyControl');
            
            if (gameMode === 'computer') {
                difficultyControl.style.display = 'flex';
            } else {
                difficultyControl.style.display = 'none';
            }
        }

        // Event listeners
        document.getElementById('gameMode').addEventListener('change', updateGameModeDisplay);

        // Initialize the game
        gameState.board = initializeBoard();
        renderBoard();
        updateTimerDisplay();
        updateGameModeDisplay();
        updateCapturedPieces();
        updateMoveHistory();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'966c7b4711fa9a8f',t:'MTc1Mzc5MDY5NS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Chess Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 226, 0.2) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundFloat 20s ease-in-out infinite;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.7; }
            33% { transform: scale(1.1) rotate(1deg); opacity: 0.8; }
            66% { transform: scale(0.9) rotate(-1deg); opacity: 0.6; }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 25px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            animation: headerGlow 3s ease-in-out infinite;
        }

        @keyframes headerGlow {
            0%, 100% { box-shadow: 0 20px 40px rgba(0,0,0,0.1), 0 0 30px rgba(102, 126, 234, 0.2); }
            50% { box-shadow: 0 25px 50px rgba(0,0,0,0.15), 0 0 40px rgba(102, 126, 234, 0.4); }
        }

        .title {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbowText 4s ease-in-out infinite;
            text-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        @keyframes rainbowText {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(78, 205, 196, 0.1));
            padding: 12px 20px;
            border-radius: 20px;
            border: 2px solid transparent;
            background-clip: padding-box;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .control-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .control-group:hover::before {
            left: 100%;
        }

        .control-group:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            border-color: #4ecdc4;
        }

        .control-group label {
            font-weight: 700;
            color: #2c3e50;
            font-size: 0.95rem;
        }

        .control-group select, .start-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .start-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-btn:hover, .control-group select:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            flex-wrap: wrap;
            max-width: 1400px;
            margin: 0 auto;
        }

        .player-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            min-width: 220px;
            max-width: 280px;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .player-section::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            animation: rotate 4s linear infinite;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .player-section.active::before {
            opacity: 1;
        }

        @keyframes rotate {
            100% { transform: rotate(360deg); }
        }

        .player-section.active {
            transform: scale(1.05);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.3);
            border-color: #4ecdc4;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: 800;
            color: #2c3e50;
            margin-bottom: 12px;
            text-align: center;
            position: relative;
            z-index: 2;
        }

        .player-timer {
            font-size: 2rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 15px;
            position: relative;
            z-index: 2;
        }

        .captured-pieces {
            margin-top: 15px;
            position: relative;
            z-index: 2;
        }

        .captured-pieces h4 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }

        .captured-piece {
            font-size: 1.2rem;
            opacity: 0.7;
            animation: captureFloat 2s ease-in-out infinite;
        }

        @keyframes captureFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }

        .chess-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .board-coordinates {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 16px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 80px);
            grid-template-rows: repeat(8, 80px);
            border: 8px solid transparent;
            border-radius: 20px;
            background: 
                linear-gradient(135deg, #667eea, #764ba2) padding-box,
                linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3) border-box;
            background-size: 400% 400%;
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.3),
                inset 0 0 30px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            animation: boardGlow 4s ease-in-out infinite;
        }

        @keyframes boardGlow {
            0%, 100% { 
                background-position: 0% 50%;
                box-shadow: 
                    0 25px 50px rgba(0,0,0,0.3),
                    inset 0 0 30px rgba(255,255,255,0.1),
                    0 0 40px rgba(102, 126, 234, 0.3);
            }
            50% { 
                background-position: 100% 50%;
                box-shadow: 
                    0 30px 60px rgba(0,0,0,0.4),
                    inset 0 0 40px rgba(255,255,255,0.2),
                    0 0 60px rgba(102, 126, 234, 0.5);
            }
        }

        .chess-board::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 25% 25%, rgba(255, 107, 107, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(78, 205, 196, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(69, 183, 209, 0.05) 0%, transparent 70%);
            animation: boardAmbient 6s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes boardAmbient {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            33% { opacity: 0.5; transform: scale(1.02); }
            66% { opacity: 0.4; transform: scale(0.98); }
        }

        .chess-square {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5rem;
            cursor: pointer;
            position: relative;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
        }

        .chess-square.light {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e, #e17055);
            position: relative;
            overflow: hidden;
        }

        .chess-square.light::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255, 234, 167, 0.8) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(253, 203, 110, 0.6) 0%, transparent 50%);
            animation: lightSquareShimmer 4s ease-in-out infinite;
        }

        @keyframes lightSquareShimmer {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.02); }
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe, #fd79a8);
            position: relative;
            overflow: hidden;
        }

        .chess-square.dark::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(108, 92, 231, 0.7) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(162, 155, 254, 0.5) 0%, transparent 50%);
            animation: darkSquareShimmer 4s ease-in-out infinite reverse;
        }

        @keyframes darkSquareShimmer {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.02); }
        }

        .chess-square:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .chess-square.selected {
            background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
            transform: scale(1.15);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
            animation: selectedPulse 1.5s ease-in-out infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { 
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 215, 0, 1), inset 0 0 30px rgba(255, 255, 255, 0.5);
            }
        }

        .chess-square.legal-move {
            background: linear-gradient(135deg, #00ff88, #00cc6a) !important;
            animation: legalMoveGlow 2s ease-in-out infinite;
        }

        @keyframes legalMoveGlow {
            0%, 100% { 
                box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
            }
            50% { 
                box-shadow: 0 0 25px rgba(0, 255, 136, 0.9);
            }
        }

        .chess-square.legal-move::after {
            content: '‚óè';
            position: absolute;
            font-size: 2rem;
            color: #006400;
            animation: moveIndicator 1.5s ease-in-out infinite;
        }

        .chess-square.legal-move.has-piece::after {
            content: '‚öî';
            font-size: 2.5rem;
            color: #dc143c;
        }

        @keyframes moveIndicator {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .chess-square.in-check {
            background: linear-gradient(135deg, #ff4757, #ff3838) !important;
            animation: checkWarning 1s ease-in-out infinite;
        }

        @keyframes checkWarning {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 71, 87, 0.8);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 30px rgba(255, 71, 87, 1);
                transform: scale(1.05);
            }
        }

        .chess-square.castle-move {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7) !important;
            animation: castleGlow 2s ease-in-out infinite;
        }

        @keyframes castleGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(162, 155, 254, 0.6); }
            50% { box-shadow: 0 0 25px rgba(162, 155, 254, 0.9); }
        }

        .chess-square.castle-move::after {
            content: 'üè∞';
            position: absolute;
            font-size: 1.5rem;
            animation: castleIndicator 1.5s ease-in-out infinite;
        }

        @keyframes castleIndicator {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .piece {
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            position: relative;
            z-index: 2;
            animation: pieceFloat 3s ease-in-out infinite;
            cursor: pointer;
        }

        @keyframes pieceFloat {
            0%, 100% { transform: translateY(0px) rotateZ(0deg); }
            33% { transform: translateY(-2px) rotateZ(1deg); }
            66% { transform: translateY(-1px) rotateZ(-1deg); }
        }

        .piece.white {
            color: #ffffff;
            text-shadow: 
                2px 2px 6px rgba(0,0,0,0.8), 
                0 0 10px rgba(255,255,255,0.5),
                0 0 20px rgba(255,215,0,0.3);
            animation: pieceFloat 3s ease-in-out infinite, whiteGlow 4s ease-in-out infinite;
        }

        @keyframes whiteGlow {
            0%, 100% { 
                text-shadow: 
                    2px 2px 6px rgba(0,0,0,0.8), 
                    0 0 10px rgba(255,255,255,0.5),
                    0 0 20px rgba(255,215,0,0.3);
            }
            50% { 
                text-shadow: 
                    2px 2px 6px rgba(0,0,0,0.8), 
                    0 0 15px rgba(255,255,255,0.8),
                    0 0 30px rgba(255,215,0,0.6);
            }
        }

        .piece.black {
            color: #2c3e50;
            text-shadow: 
                2px 2px 6px rgba(255,255,255,0.3), 
                0 0 10px rgba(44,62,80,0.7),
                0 0 20px rgba(108,92,231,0.4);
            animation: pieceFloat 3s ease-in-out infinite, blackGlow 4s ease-in-out infinite;
        }

        @keyframes blackGlow {
            0%, 100% { 
                text-shadow: 
                    2px 2px 6px rgba(255,255,255,0.3), 
                    0 0 10px rgba(44,62,80,0.7),
                    0 0 20px rgba(108,92,231,0.4);
            }
            50% { 
                text-shadow: 
                    2px 2px 6px rgba(255,255,255,0.3), 
                    0 0 15px rgba(44,62,80,1),
                    0 0 30px rgba(108,92,231,0.7);
            }
        }

        .piece:hover {
            transform: scale(1.3) translateY(-8px) rotateZ(5deg);
            filter: drop-shadow(8px 8px 20px rgba(0,0,0,0.8));
            animation: pieceHover 0.6s ease-in-out infinite;
        }

        @keyframes pieceHover {
            0%, 100% { transform: scale(1.3) translateY(-8px) rotateZ(5deg); }
            50% { transform: scale(1.35) translateY(-12px) rotateZ(-5deg); }
        }

        .piece.moving {
            animation: pieceMove 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 100;
        }

        @keyframes pieceMove {
            0% { 
                transform: scale(1) rotateZ(0deg); 
                filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            }
            25% { 
                transform: scale(1.4) translateY(-15px) rotateZ(10deg); 
                filter: drop-shadow(10px 10px 25px rgba(0,0,0,0.8));
            }
            75% { 
                transform: scale(1.2) translateY(-8px) rotateZ(-5deg); 
                filter: drop-shadow(8px 8px 20px rgba(0,0,0,0.6));
            }
            100% { 
                transform: scale(1) rotateZ(0deg); 
                filter: drop-shadow(3px 3px 8px rgba(0,0,0,0.4));
            }
        }

        .piece.captured {
            animation: pieceCaptured 1s ease-in-out forwards;
        }

        @keyframes pieceCaptured {
            0% { 
                transform: scale(1) rotateZ(0deg); 
                opacity: 1;
            }
            50% { 
                transform: scale(1.5) rotateZ(180deg) translateY(-20px); 
                opacity: 0.7;
            }
            100% { 
                transform: scale(0) rotateZ(360deg) translateY(-40px); 
                opacity: 0;
            }
        }

        .game-status {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-top: 20px;
            text-align: center;
            color: #2c3e50;
            font-size: 1.3rem;
            font-weight: 700;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.5s ease;
        }

        .game-status.check {
            background: linear-gradient(135deg, #ff4757, #ff3838);
            color: white;
            animation: checkAlert 1s ease-in-out infinite;
        }

        @keyframes checkAlert {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .game-status.checkmate {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #2c3e50;
            animation: victoryDance 2s ease-in-out infinite;
        }

        @keyframes victoryDance {
            0%, 100% { transform: scale(1) rotateZ(0deg); }
            25% { transform: scale(1.1) rotateZ(2deg); }
            75% { transform: scale(1.1) rotateZ(-2deg); }
        }

        .thinking-indicator {
            display: none;
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            padding: 12px 20px;
            border-radius: 15px;
            font-weight: 600;
            margin-top: 15px;
            animation: thinking 1.5s ease-in-out infinite;
            position: relative;
            z-index: 2;
        }

        .thinking-indicator.show {
            display: block;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .move-history {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 12px;
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
            position: relative;
            z-index: 2;
        }

        .move-history h4 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .move-item {
            padding: 4px 8px;
            margin: 2px 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(78, 205, 196, 0.1));
            border-radius: 6px;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .move-item:hover {
            transform: translateX(5px);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(78, 205, 196, 0.2));
        }

        .undo-controls {
            margin-top: 12px;
            text-align: center;
        }

        .undo-btn {
            background: linear-gradient(135deg, #ff7675, #fd79a8);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            font-size: 0.8rem;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 15px rgba(255, 118, 117, 0.3);
            position: relative;
            overflow: hidden;
        }

        .undo-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .undo-btn:hover::before {
            left: 100%;
        }

        .undo-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 118, 117, 0.5);
        }

        .undo-btn:disabled {
            background: linear-gradient(135deg, #b2bec3, #636e72);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .undo-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        /* Victory Celebration Popup */
        .victory-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .victory-popup.show {
            display: flex;
            animation: popupFadeIn 0.5s ease-out;
        }

        @keyframes popupFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .victory-content {
            background: linear-gradient(135deg, #ffd700, #ffed4e, #feca57);
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            box-shadow: 0 30px 60px rgba(0,0,0,0.5);
            border: 5px solid #fff;
            position: relative;
            overflow: hidden;
            animation: victoryBounce 1s ease-out;
            max-width: 90vw;
            max-height: 90vh;
        }

        @keyframes victoryBounce {
            0% { transform: scale(0.3) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .victory-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: victorySparkle 3s linear infinite;
        }

        @keyframes victorySparkle {
            100% { transform: rotate(360deg); }
        }

        .victory-title {
            font-size: 4rem;
            font-weight: 900;
            color: #2c3e50;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            position: relative;
            z-index: 2;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .victory-message {
            font-size: 1.8rem;
            color: #2c3e50;
            margin-bottom: 30px;
            font-weight: 700;
            position: relative;
            z-index: 2;
        }

        .victory-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            position: relative;
            z-index: 2;
        }

        .victory-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .victory-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.6);
        }

        .victory-btn.restart {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .victory-btn.restart:hover {
            box-shadow: 0 15px 35px rgba(255, 107, 107, 0.6);
        }

        /* Flying Flowers Animation */
        .flower {
            position: absolute;
            font-size: 2rem;
            pointer-events: none;
            z-index: 999;
            animation: flyFlower 4s ease-out forwards;
        }

        @keyframes flyFlower {
            0% {
                transform: translateY(100vh) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) rotate(36deg) scale(1);
            }
            90% {
                opacity: 1;
                transform: translateY(-10vh) rotate(720deg) scale(1);
            }
            100% {
                transform: translateY(-20vh) rotate(720deg) scale(0);
                opacity: 0;
            }
        }

        /* Confetti Animation */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            pointer-events: none;
            z-index: 998;
            animation: confettiFall 3s ease-out forwards;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Enhanced Board Animations from Version 2 */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 100px);
            grid-template-rows: repeat(8, 100px);
            border: 8px solid transparent;
            border-radius: 20px;
            background: 
                linear-gradient(135deg, #667eea, #764ba2) padding-box,
                linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3) border-box;
            background-size: 400% 400%;
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.3),
                inset 0 0 30px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            animation: boardGlow 4s ease-in-out infinite, boardFloat 6s ease-in-out infinite;
        }

        @keyframes boardFloat {
            0%, 100% { 
                transform: translateY(0px) rotateX(0deg) rotateY(0deg);
            }
            33% { 
                transform: translateY(-5px) rotateX(2deg) rotateY(1deg);
            }
            66% { 
                transform: translateY(-2px) rotateX(-1deg) rotateY(-2deg);
            }
        }

        .chess-board::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
            background-size: 400% 400%;
            border-radius: 25px;
            z-index: -1;
            animation: borderRainbow 3s ease-in-out infinite;
            filter: blur(15px);
            opacity: 0.7;
        }

        @keyframes borderRainbow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .chess-square {
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4.5rem;
            cursor: pointer;
            position: relative;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            animation: squareBreath 4s ease-in-out infinite;
        }

        @keyframes squareBreath {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .chess-square.light {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e, #e17055);
            position: relative;
            overflow: hidden;
        }

        .chess-square.light::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255, 234, 167, 0.8) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(253, 203, 110, 0.6) 0%, transparent 50%);
            animation: lightSquareShimmer 4s ease-in-out infinite;
        }

        .chess-square.light::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: lightSparkle 3s ease-in-out infinite;
        }

        @keyframes lightSparkle {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe, #fd79a8);
            position: relative;
            overflow: hidden;
        }

        .chess-square.dark::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(108, 92, 231, 0.7) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(162, 155, 254, 0.5) 0%, transparent 50%);
            animation: darkSquareShimmer 4s ease-in-out infinite reverse;
        }

        .chess-square.dark::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, rgba(162, 155, 254, 0.4) 0%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: darkSparkle 3s ease-in-out infinite reverse;
        }

        @keyframes darkSparkle {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .player-section {
                max-width: 600px;
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .chess-board {
                grid-template-columns: repeat(8, 60px);
                grid-template-rows: repeat(8, 60px);
            }
            
            .chess-square {
                width: 60px;
                height: 60px;
                font-size: 2.5rem;
            }
            
            .board-coordinates {
                width: 480px;
            }
            
            .title {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            .chess-board {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }
            
            .chess-square {
                width: 45px;
                height: 45px;
                font-size: 2rem;
            }
            
            .board-coordinates {
                width: 360px;
            }
            
            .victory-content {
                padding: 30px 20px;
                margin: 20px;
            }
            
            .victory-title {
                font-size: 2.5rem;
            }
            
            .victory-message {
                font-size: 1.3rem;
            }
            
            .victory-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .victory-btn {
                width: 100%;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">‚ôî PROFESSIONAL CHESS ARENA ‚ôõ</h1>
        <div class="controls">
            <div class="control-group">
                <label for="gameMode">üéÆ Game Mode:</label>
                <select id="gameMode">
                    <option value="2player">2 Players</option>
                    <option value="computer">vs Computer</option>
                </select>
            </div>
            <div class="control-group" id="difficultyControl" style="display: none;">
                <label for="difficulty">üß† AI Difficulty:</label>
                <select id="difficulty">
                    <option value="easy">Easy</option>
                    <option value="medium">Medium</option>
                    <option value="hard">Hard</option>
                    <option value="expert">Expert</option>
                </select>
            </div>
            <div class="control-group">
                <label for="timeLimit">‚è±Ô∏è Time Control:</label>
                <select id="timeLimit">
                    <option value="60">1 Minute</option>
                    <option value="300" selected>5 Minutes</option>
                    <option value="600">10 Minutes</option>
                    <option value="unlimited">Unlimited</option>
                </select>
            </div>
            <button class="start-btn" onclick="startGame()">üöÄ Start Battle</button>
        </div>
    </div>

    <div class="game-container">
        <div class="player-section" id="player1Info">
            <div class="player-name">Player 1 ‚ôî</div>
            <div class="player-timer" id="player1Timer">5:00</div>
            <div class="captured-pieces">
                <h4>Captured Pieces:</h4>
                <div class="captured-list" id="player1Captured"></div>
            </div>
            <div class="move-history">
                <h4>Move History:</h4>
                <div id="moveHistory"></div>
                <div class="undo-controls">
                    <button class="undo-btn" id="undoBtn" onclick="undoLastMove()">
                        ‚è™ Undo Move
                    </button>
                </div>
            </div>
        </div>

        <div class="chess-board-container">
            <div class="board-coordinates">
                <span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span>
            </div>
            <div class="chess-board" id="chessBoard"></div>
        </div>

        <div class="player-section" id="player2Info">
            <div class="player-name">Player 2 ‚ôõ</div>
            <div class="player-timer" id="player2Timer">5:00</div>
            <div class="captured-pieces">
                <h4>Captured Pieces:</h4>
                <div class="captured-list" id="player2Captured"></div>
            </div>
            <div class="thinking-indicator" id="thinkingIndicator">
                ü§ñ AI is calculating the perfect move...
            </div>
        </div>
    </div>

    <div class="game-status" id="gameStatus">üéØ Configure your game settings and click "Start Battle" to begin the ultimate chess experience! üéØ</div>

    <!-- Victory Celebration Popup -->
    <div class="victory-popup" id="victoryPopup">
        <div class="victory-content">
            <div class="victory-title" id="victoryTitle">üéâ VICTORY! üéâ</div>
            <div class="victory-message" id="victoryMessage">Congratulations on your amazing win!</div>
            <div class="victory-buttons">
                <button class="victory-btn restart" onclick="closeVictoryPopup(); startGame();">
                    üîÑ Play Again
                </button>
                <button class="victory-btn" onclick="closeVictoryPopup();">
                    üìä View Board
                </button>
            </div>
        </div>
    </div>

    <script>
        // Chess pieces using Unicode symbols
        const pieces = {
            'white': {
                'king': '‚ôî', 'queen': '‚ôï', 'rook': '‚ôñ', 
                'bishop': '‚ôó', 'knight': '‚ôò', 'pawn': '‚ôô'
            },
            'black': {
                'king': '‚ôö', 'queen': '‚ôõ', 'rook': '‚ôú', 
                'bishop': '‚ôù', 'knight': '‚ôû', 'pawn': '‚ôü'
            }
        };

        // Piece values for AI evaluation
        const pieceValues = {
            'pawn': 1, 'knight': 3, 'bishop': 3, 
            'rook': 5, 'queen': 9, 'king': 1000
        };

        // Game state
        let gameState = {
            board: [],
            currentPlayer: 'white',
            selectedSquare: null,
            gameStarted: false,
            gameOver: false,
            player1Time: 300,
            player2Time: 300,
            timer: null,
            gameMode: '2player',
            difficulty: 'medium',
            isComputerTurn: false,
            moveHistory: [],
            gameStateHistory: [], // Store previous game states for undo
            capturedPieces: { white: [], black: [] },
            castlingRights: {
                white: { kingside: true, queenside: true },
                black: { kingside: true, queenside: true }
            },
            kingMoved: { white: false, black: false },
            rookMoved: {
                white: { kingside: false, queenside: false },
                black: { kingside: false, queenside: false }
            },
            enPassantTarget: null,
            isInCheck: { white: false, black: false }
        };

        // Initialize the chess board
        function initializeBoard() {
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            const initialSetup = [
                ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],
                ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn']
            ];

            // Black pieces
            for (let col = 0; col < 8; col++) {
                board[0][col] = { color: 'black', piece: initialSetup[0][col] };
                board[1][col] = { color: 'black', piece: initialSetup[1][col] };
            }

            // White pieces
            for (let col = 0; col < 8; col++) {
                board[7][col] = { color: 'white', piece: initialSetup[0][col] };
                board[6][col] = { color: 'white', piece: initialSetup[1][col] };
            }

            return board;
        }

        // Render the chess board
        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'chess-square';
                    square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Highlight king if in check
                    const piece = gameState.board[row][col];
                    if (piece && piece.piece === 'king' && gameState.isInCheck[piece.color]) {
                        square.classList.add('in-check');
                    }

                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = `piece ${piece.color}`;
                        pieceElement.textContent = pieces[piece.color][piece.piece];
                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
        }

        // Handle square clicks
        function handleSquareClick(row, col) {
            if (!gameState.gameStarted || gameState.gameOver || gameState.isComputerTurn) return;

            const square = gameState.board[row][col];

            // Clear previous selections and highlights
            clearHighlights();

            if (gameState.selectedSquare) {
                const [selectedRow, selectedCol] = gameState.selectedSquare;
                
                if (row === selectedRow && col === selectedCol) {
                    gameState.selectedSquare = null;
                    return;
                }

                // Try to move piece
                if (isValidMove(selectedRow, selectedCol, row, col)) {
                    const moveResult = movePiece(selectedRow, selectedCol, row, col);
                    if (moveResult) {
                        gameState.selectedSquare = null;
                        switchPlayer();
                        return;
                    }
                }
            }

            // Select piece if it belongs to current player
            if (square && square.color === gameState.currentPlayer) {
                gameState.selectedSquare = [row, col];
                highlightSelectedSquare(row, col);
                highlightLegalMoves(row, col);
            }
        }

        // Clear all highlights
        function clearHighlights() {
            document.querySelectorAll('.chess-square').forEach(sq => {
                sq.classList.remove('selected', 'legal-move', 'has-piece', 'castle-move');
            });
        }

        // Highlight selected square
        function highlightSelectedSquare(row, col) {
            const squareElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            squareElement.classList.add('selected');
        }

        // Highlight all legal moves for selected piece
        function highlightLegalMoves(row, col) {
            const legalMoves = getValidMoves(row, col);
            legalMoves.forEach(([r, c, moveType]) => {
                const squareElement = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                
                if (moveType === 'castle') {
                    squareElement.classList.add('castle-move');
                } else {
                    squareElement.classList.add('legal-move');
                    if (gameState.board[r][c]) {
                        squareElement.classList.add('has-piece');
                    }
                }
            });
        }

        // Check if a square is under attack by the opponent
        function isSquareUnderAttack(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = gameState.board[r][c];
                    if (piece && piece.color === byColor) {
                        if (canPieceAttackSquare(r, c, row, col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Check if a piece can attack a specific square
        function canPieceAttackSquare(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            if (!piece) return false;

            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch (piece.piece) {
                case 'pawn':
                    const direction = piece.color === 'white' ? -1 : 1;
                    return Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction;

                case 'rook':
                    return (fromRow === toRow || fromCol === toCol) && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'bishop':
                    return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'queen':
                    return ((fromRow === toRow || fromCol === toCol) || rowDiff === colDiff) && 
                           isPathClear(fromRow, fromCol, toRow, toCol);

                case 'king':
                    return rowDiff <= 1 && colDiff <= 1;

                case 'knight':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                default:
                    return false;
            }
        }

        // Find king position
        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color && piece.piece === 'king') {
                        return [row, col];
                    }
                }
            }
            return null;
        }

        // Check if king is in check
        function isKingInCheck(color) {
            const kingPos = findKing(color);
            if (!kingPos) return false;
            
            const [kingRow, kingCol] = kingPos;
            const opponentColor = color === 'white' ? 'black' : 'white';
            return isSquareUnderAttack(kingRow, kingCol, opponentColor);
        }

        // Check if move would leave king in check
        function wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // Make temporary move
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            const inCheck = isKingInCheck(piece.color);
            
            // Undo temporary move
            gameState.board[fromRow][fromCol] = piece;
            gameState.board[toRow][toCol] = capturedPiece;
            
            return inCheck;
        }

        // Enhanced move validation with all chess rules
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 ||
                toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;

            const piece = gameState.board[fromRow][fromCol];
            const targetSquare = gameState.board[toRow][toCol];

            if (!piece) return false;
            if (targetSquare && targetSquare.color === piece.color) return false;

            // Check basic piece movement rules
            if (!isBasicMoveValid(fromRow, fromCol, toRow, toCol)) return false;

            // Check if move would leave king in check
            if (wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol)) return false;

            return true;
        }

        // Basic piece movement validation
        function isBasicMoveValid(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const targetSquare = gameState.board[toRow][toCol];
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch (piece.piece) {
                case 'pawn':
                    const direction = piece.color === 'white' ? -1 : 1;
                    const startRow = piece.color === 'white' ? 6 : 1;
                    
                    // Forward move
                    if (fromCol === toCol && !targetSquare) {
                        return (toRow === fromRow + direction) || 
                               (fromRow === startRow && toRow === fromRow + 2 * direction);
                    }
                    // Diagonal capture
                    if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {
                        return targetSquare || isEnPassantCapture(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'rook':
                    return (fromRow === toRow || fromCol === toCol) && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'bishop':
                    return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol);

                case 'queen':
                    return ((fromRow === toRow || fromCol === toCol) || rowDiff === colDiff) && 
                           isPathClear(fromRow, fromCol, toRow, toCol);

                case 'king':
                    // Normal king move
                    if (rowDiff <= 1 && colDiff <= 1) return true;
                    
                    // Castling
                    if (rowDiff === 0 && colDiff === 2) {
                        return canCastle(piece.color, toCol > fromCol ? 'kingside' : 'queenside');
                    }
                    return false;

                case 'knight':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                default:
                    return false;
            }
        }

        // Check if path is clear
        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                if (gameState.board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }

            return true;
        }

        // Check if castling is possible
        function canCastle(color, side) {
            if (gameState.kingMoved[color]) return false;
            if (gameState.rookMoved[color][side]) return false;
            if (isKingInCheck(color)) return false;

            const row = color === 'white' ? 7 : 0;
            const kingCol = 4;
            const rookCol = side === 'kingside' ? 7 : 0;
            const direction = side === 'kingside' ? 1 : -1;

            // Check if squares between king and rook are empty
            for (let col = kingCol + direction; col !== rookCol; col += direction) {
                if (gameState.board[row][col]) return false;
            }

            // Check if king passes through or ends up in check
            const opponentColor = color === 'white' ? 'black' : 'white';
            for (let i = 0; i <= 2; i++) {
                const checkCol = kingCol + (i * direction);
                if (isSquareUnderAttack(row, checkCol, opponentColor)) return false;
            }

            return true;
        }

        // Check if move is en passant capture
        function isEnPassantCapture(fromRow, fromCol, toRow, toCol) {
            if (!gameState.enPassantTarget) return false;
            const [targetRow, targetCol] = gameState.enPassantTarget;
            return toRow === targetRow && toCol === targetCol;
        }

        // Get all valid moves for a piece
        function getValidMoves(row, col) {
            const moves = [];
            const piece = gameState.board[row][col];
            
            if (!piece) return moves;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        // Check if it's a castling move
                        if (piece.piece === 'king' && Math.abs(c - col) === 2) {
                            moves.push([r, c, 'castle']);
                        } else {
                            moves.push([r, c, 'normal']);
                        }
                    }
                }
            }
            return moves;
        }

        // Get all possible moves for a color
        function getAllPossibleMoves(color) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color) {
                        const validMoves = getValidMoves(row, col);
                        validMoves.forEach(move => {
                            moves.push({
                                from: [row, col],
                                to: [move[0], move[1]],
                                piece: piece,
                                moveType: move[2] || 'normal'
                            });
                        });
                    }
                }
            }
            return moves;
        }

        // Check for checkmate or stalemate
        function isCheckmate(color) {
            if (!isKingInCheck(color)) return false;
            return getAllPossibleMoves(color).length === 0;
        }

        function isStalemate(color) {
            if (isKingInCheck(color)) return false;
            return getAllPossibleMoves(color).length === 0;
        }

        // Save current game state for undo functionality
        function saveGameState() {
            const stateCopy = {
                board: gameState.board.map(row => row.map(cell => cell ? {...cell} : null)),
                currentPlayer: gameState.currentPlayer,
                capturedPieces: {
                    white: [...gameState.capturedPieces.white],
                    black: [...gameState.capturedPieces.black]
                },
                castlingRights: {
                    white: {...gameState.castlingRights.white},
                    black: {...gameState.castlingRights.black}
                },
                kingMoved: {...gameState.kingMoved},
                rookMoved: {
                    white: {...gameState.rookMoved.white},
                    black: {...gameState.rookMoved.black}
                },
                enPassantTarget: gameState.enPassantTarget ? [...gameState.enPassantTarget] : null,
                isInCheck: {...gameState.isInCheck},
                player1Time: gameState.player1Time,
                player2Time: gameState.player2Time,
                moveHistory: [...gameState.moveHistory]
            };
            
            gameState.gameStateHistory.push(stateCopy);
            
            // Keep only last 10 moves to prevent memory issues
            if (gameState.gameStateHistory.length > 10) {
                gameState.gameStateHistory.shift();
            }
            
            updateUndoButton();
        }

        // Undo last move
        function undoLastMove() {
            if (gameState.gameStateHistory.length === 0 || gameState.gameOver || 
                (gameState.gameMode === 'computer' && gameState.isComputerTurn)) {
                return;
            }

            // In computer mode, undo both player and AI moves
            if (gameState.gameMode === 'computer' && gameState.gameStateHistory.length >= 2) {
                gameState.gameStateHistory.pop(); // Remove AI move
                if (gameState.gameStateHistory.length > 0) {
                    gameState.gameStateHistory.pop(); // Remove player move
                }
            } else if (gameState.gameStateHistory.length > 0) {
                gameState.gameStateHistory.pop(); // Remove last move
            }

            if (gameState.gameStateHistory.length > 0) {
                const previousState = gameState.gameStateHistory[gameState.gameStateHistory.length - 1];
                
                // Restore game state
                gameState.board = previousState.board.map(row => row.map(cell => cell ? {...cell} : null));
                gameState.currentPlayer = previousState.currentPlayer;
                gameState.capturedPieces = {
                    white: [...previousState.capturedPieces.white],
                    black: [...previousState.capturedPieces.black]
                };
                gameState.castlingRights = {
                    white: {...previousState.castlingRights.white},
                    black: {...previousState.castlingRights.black}
                };
                gameState.kingMoved = {...previousState.kingMoved};
                gameState.rookMoved = {
                    white: {...previousState.rookMoved.white},
                    black: {...previousState.rookMoved.black}
                };
                gameState.enPassantTarget = previousState.enPassantTarget ? [...previousState.enPassantTarget] : null;
                gameState.isInCheck = {...previousState.isInCheck};
                gameState.player1Time = previousState.player1Time;
                gameState.player2Time = previousState.player2Time;
                gameState.moveHistory = [...previousState.moveHistory];
                
                // Remove the state we just restored from history
                gameState.gameStateHistory.pop();
            } else {
                // If no history, reset to initial state
                gameState.board = initializeBoard();
                gameState.currentPlayer = 'white';
                gameState.capturedPieces = { white: [], black: [] };
                gameState.castlingRights = {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                };
                gameState.kingMoved = { white: false, black: false };
                gameState.rookMoved = {
                    white: { kingside: false, queenside: false },
                    black: { kingside: false, queenside: false }
                };
                gameState.enPassantTarget = null;
                gameState.isInCheck = { white: false, black: false };
                gameState.moveHistory = [];
            }

            clearHighlights();
            gameState.selectedSquare = null;
            renderBoard();
            updatePlayerDisplay();
            updateCapturedPieces();
            updateMoveHistory();
            updateGameStatus();
            updateUndoButton();
        }

        // Update undo button state
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            const canUndo = gameState.gameStateHistory.length > 0 && 
                           !gameState.gameOver && 
                           !(gameState.gameMode === 'computer' && gameState.isComputerTurn);
            
            undoBtn.disabled = !canUndo;
        }

        // Move piece with all special rules
        function movePiece(fromRow, fromCol, toRow, toCol) {
            // Save current state before making move
            saveGameState();
            
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // Handle castling
            if (piece.piece === 'king' && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? 5 : 3;
                const row = fromRow;
                
                // Move rook
                gameState.board[row][rookToCol] = gameState.board[row][rookFromCol];
                gameState.board[row][rookFromCol] = null;
                
                gameState.kingMoved[piece.color] = true;
                gameState.rookMoved[piece.color][isKingside ? 'kingside' : 'queenside'] = true;
            }

            // Handle en passant capture
            if (piece.piece === 'pawn' && isEnPassantCapture(fromRow, fromCol, toRow, toCol)) {
                const captureRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                const capturedPawn = gameState.board[captureRow][toCol];
                gameState.capturedPieces[capturedPawn.color].push(capturedPawn);
                gameState.board[captureRow][toCol] = null;
            }

            // Set en passant target for next move
            gameState.enPassantTarget = null;
            if (piece.piece === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                gameState.enPassantTarget = [fromRow + (toRow - fromRow) / 2, fromCol];
            }

            // Handle regular capture with animation
            if (capturedPiece) {
                // Add capture animation
                const capturedElement = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"] .piece`);
                if (capturedElement) {
                    capturedElement.classList.add('captured');
                    setTimeout(() => {
                        gameState.capturedPieces[capturedPiece.color].push(capturedPiece);
                        updateCapturedPieces();
                    }, 500);
                } else {
                    gameState.capturedPieces[capturedPiece.color].push(capturedPiece);
                }
            }

            // Move the piece
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;

            // Update castling rights
            if (piece.piece === 'king') {
                gameState.kingMoved[piece.color] = true;
            }
            if (piece.piece === 'rook') {
                if (fromCol === 0) gameState.rookMoved[piece.color].queenside = true;
                if (fromCol === 7) gameState.rookMoved[piece.color].kingside = true;
            }

            // Handle pawn promotion
            if (piece.piece === 'pawn' && (toRow === 0 || toRow === 7)) {
                gameState.board[toRow][toCol] = { color: piece.color, piece: 'queen' };
            }

            // Add move to history
            const moveNotation = `${pieces[piece.color][piece.piece]} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} ‚Üí ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            gameState.moveHistory.push(moveNotation);

            // Add piece animation
            const pieceElement = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"] .piece`);
            if (pieceElement) {
                pieceElement.classList.add('moving');
                setTimeout(() => pieceElement.classList.remove('moving'), 500);
            }

            renderBoard();
            updateCapturedPieces();
            updateMoveHistory();
            
            return true;
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            const player1Captured = document.getElementById('player1Captured');
            const player2Captured = document.getElementById('player2Captured');
            
            player1Captured.innerHTML = gameState.capturedPieces.black.map(piece => 
                `<span class="captured-piece">${pieces.black[piece.piece]}</span>`
            ).join('');
            
            player2Captured.innerHTML = gameState.capturedPieces.white.map(piece => 
                `<span class="captured-piece">${pieces.white[piece.piece]}</span>`
            ).join('');
        }

        // Update move history display
        function updateMoveHistory() {
            const historyElement = document.getElementById('moveHistory');
            historyElement.innerHTML = gameState.moveHistory.slice(-10).map((move, index) => 
                `<div class="move-item">${gameState.moveHistory.length - 10 + index + 1}. ${move}</div>`
            ).join('');
            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Switch players
        function switchPlayer() {
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            
            // Update check status
            gameState.isInCheck.white = isKingInCheck('white');
            gameState.isInCheck.black = isKingInCheck('black');
            
            updatePlayerDisplay();
            updateGameStatus();

            // Check for game end conditions
            if (isCheckmate(gameState.currentPlayer)) {
                const winner = gameState.currentPlayer === 'white' ? 'Black' : 'White';
                endGame(`üéâ CHECKMATE! ${winner} wins! üéâ`, 'checkmate');
                return;
            }
            
            if (isStalemate(gameState.currentPlayer)) {
                endGame('ü§ù STALEMATE! It\'s a draw! ü§ù', 'stalemate');
                return;
            }

            // Trigger AI move if it's computer's turn
            if (gameState.gameMode === 'computer' && gameState.currentPlayer === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }

        // Update player display
        function updatePlayerDisplay() {
            const player1Info = document.getElementById('player1Info');
            const player2Info = document.getElementById('player2Info');

            player1Info.classList.toggle('active', gameState.currentPlayer === 'white');
            player2Info.classList.toggle('active', gameState.currentPlayer === 'black');
        }

        // Update game status
        function updateGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            
            if (!gameState.gameOver && gameState.gameStarted) {
                let statusText;
                let statusClass = '';
                
                if (gameState.isInCheck[gameState.currentPlayer]) {
                    statusText = `‚ö†Ô∏è CHECK! ${gameState.currentPlayer === 'white' ? 'White' : 'Black'} king is in danger! ‚ö†Ô∏è`;
                    statusClass = 'check';
                } else if (gameState.gameMode === 'computer') {
                    statusText = gameState.currentPlayer === 'white' ? 
                        "üéØ Your turn - Make your strategic move! üéØ" : 
                        "ü§ñ AI is analyzing the position... ü§ñ";
                } else {
                    const currentPlayerName = gameState.currentPlayer === 'white' ? 'White' : 'Black';
                    statusText = `‚ö° ${currentPlayerName}'s turn - Plan your next move! ‚ö°`;
                }
                
                statusElement.textContent = statusText;
                statusElement.className = `game-status ${statusClass}`;
            }
        }

        // AI move calculation (enhanced)
        function evaluateBoard() {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        let value = pieceValues[piece.piece];
                        
                        // Add positional bonuses
                        if (piece.piece === 'pawn') {
                            // Pawns are more valuable when advanced
                            const advancement = piece.color === 'white' ? (6 - row) : (row - 1);
                            value += advancement * 0.1;
                        }
                        
                        if (piece.piece === 'knight' || piece.piece === 'bishop') {
                            // Knights and bishops are better in center
                            const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);
                            value += (7 - centerDistance) * 0.1;
                        }
                        
                        score += piece.color === 'black' ? value : -value;
                    }
                }
            }
            
            // Add bonus for check
            if (gameState.isInCheck.white) score += 0.5;
            if (gameState.isInCheck.black) score -= 0.5;
            
            return score;
        }

        // Minimax algorithm with alpha-beta pruning
        function minimax(depth, isMaximizing, alpha = -Infinity, beta = Infinity) {
            if (depth === 0) {
                return evaluateBoard();
            }

            const moves = getAllPossibleMoves(isMaximizing ? 'black' : 'white');
            
            if (moves.length === 0) {
                const color = isMaximizing ? 'black' : 'white';
                if (isKingInCheck(color)) {
                    return isMaximizing ? -10000 : 10000; // Checkmate
                } else {
                    return 0; // Stalemate
                }
            }

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const [fromRow, fromCol] = move.from;
                    const [toRow, toCol] = move.to;
                    
                    // Make move
                    const capturedPiece = gameState.board[toRow][toCol];
                    const originalEnPassant = gameState.enPassantTarget;
                    gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                    gameState.board[fromRow][fromCol] = null;

                    const eval = minimax(depth - 1, false, alpha, beta);
                    
                    // Undo move
                    gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                    gameState.board[toRow][toCol] = capturedPiece;
                    gameState.enPassantTarget = originalEnPassant;

                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break; // Alpha-beta pruning
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const [fromRow, fromCol] = move.from;
                    const [toRow, toCol] = move.to;
                    
                    // Make move
                    const capturedPiece = gameState.board[toRow][toCol];
                    const originalEnPassant = gameState.enPassantTarget;
                    gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                    gameState.board[fromRow][fromCol] = null;

                    const eval = minimax(depth - 1, true, alpha, beta);
                    
                    // Undo move
                    gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                    gameState.board[toRow][toCol] = capturedPiece;
                    gameState.enPassantTarget = originalEnPassant;

                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break; // Alpha-beta pruning
                }
                return minEval;
            }
        }

        // Calculate best AI move
        function calculateAIMove() {
            const difficultyDepth = {
                'easy': 1,
                'medium': 2,
                'hard': 3,
                'expert': 4
            };

            const depth = difficultyDepth[gameState.difficulty];
            const moves = getAllPossibleMoves('black');
            
            if (moves.length === 0) return null;

            // Add randomness for easier difficulties
            if (gameState.difficulty === 'easy' && Math.random() < 0.4) {
                return moves[Math.floor(Math.random() * moves.length)];
            }

            let bestMove = null;
            let bestValue = -Infinity;

            for (const move of moves) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                // Make move
                const capturedPiece = gameState.board[toRow][toCol];
                const originalEnPassant = gameState.enPassantTarget;
                gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
                gameState.board[fromRow][fromCol] = null;

                const moveValue = minimax(depth - 1, false);
                
                // Undo move
                gameState.board[fromRow][fromCol] = gameState.board[toRow][toCol];
                gameState.board[toRow][toCol] = capturedPiece;
                gameState.enPassantTarget = originalEnPassant;

                if (moveValue > bestValue) {
                    bestValue = moveValue;
                    bestMove = move;
                }
            }

            return bestMove;
        }

        // Execute AI move
        function makeAIMove() {
            if (gameState.gameMode !== 'computer' || gameState.currentPlayer !== 'black') return;

            gameState.isComputerTurn = true;
            document.getElementById('thinkingIndicator').classList.add('show');

            setTimeout(() => {
                const aiMove = calculateAIMove();
                if (aiMove) {
                    const [fromRow, fromCol] = aiMove.from;
                    const [toRow, toCol] = aiMove.to;
                    movePiece(fromRow, fromCol, toRow, toCol);
                    switchPlayer();
                }
                
                document.getElementById('thinkingIndicator').classList.remove('show');
                gameState.isComputerTurn = false;
            }, Math.random() * 1500 + 1000);
        }

        // Timer functions
        function startTimer() {
            const timeLimit = document.getElementById('timeLimit').value;
            if (timeLimit === 'unlimited') return;

            // Clear any existing timer
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }

            gameState.timer = setInterval(() => {
                if (gameState.gameOver || !gameState.gameStarted) {
                    clearInterval(gameState.timer);
                    return;
                }

                if (gameState.currentPlayer === 'white') {
                    gameState.player1Time--;
                    if (gameState.player1Time <= 0) {
                        gameState.player1Time = 0;
                        clearInterval(gameState.timer);
                        endGame('‚è∞ Time\'s up! Black wins by timeout! ‚è∞', 'timeout');
                        return;
                    }
                } else {
                    gameState.player2Time--;
                    if (gameState.player2Time <= 0) {
                        gameState.player2Time = 0;
                        clearInterval(gameState.timer);
                        endGame('‚è∞ Time\'s up! White wins by timeout! ‚è∞', 'timeout');
                        return;
                    }
                }
                updateTimerDisplay();
            }, 1000); // Update every second
        }

        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                if (seconds < 0) return "0:00";
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const timeLimit = document.getElementById('timeLimit').value;
            if (timeLimit === 'unlimited') {
                document.getElementById('player1Timer').textContent = '‚àû';
                document.getElementById('player2Timer').textContent = '‚àû';
            } else {
                document.getElementById('player1Timer').textContent = formatTime(gameState.player1Time);
                document.getElementById('player2Timer').textContent = formatTime(gameState.player2Time);
            }
        }

        // Start game
        function startGame() {
            const timeLimit = document.getElementById('timeLimit').value;
            const timeLimitSeconds = timeLimit === 'unlimited' ? Infinity : parseInt(timeLimit);
            
            // Clear any existing timer first
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }

            // Reset game state
            gameState = {
                board: initializeBoard(),
                currentPlayer: 'white',
                selectedSquare: null,
                gameStarted: true,
                gameOver: false,
                player1Time: timeLimitSeconds,
                player2Time: timeLimitSeconds,
                timer: null,
                gameMode: document.getElementById('gameMode').value,
                difficulty: document.getElementById('difficulty').value,
                isComputerTurn: false,
                moveHistory: [],
                gameStateHistory: [], // Reset undo history
                capturedPieces: { white: [], black: [] },
                castlingRights: {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                },
                kingMoved: { white: false, black: false },
                rookMoved: {
                    white: { kingside: false, queenside: false },
                    black: { kingside: false, queenside: false }
                },
                enPassantTarget: null,
                isInCheck: { white: false, black: false }
            };

            // Update player names
            document.querySelector('#player1Info .player-name').textContent = 'Player 1 ‚ôî';
            document.querySelector('#player2Info .player-name').textContent = 
                gameState.gameMode === 'computer' ? 'AI Computer ‚ôõ' : 'Player 2 ‚ôõ';

            clearHighlights();
            renderBoard();
            updatePlayerDisplay();
            updateTimerDisplay();
            updateCapturedPieces();
            updateMoveHistory();
            updateUndoButton();
            
            if (timeLimit !== 'unlimited') startTimer();
            updateGameStatus();
            
            document.querySelector('.start-btn').textContent = 'üîÑ Restart Battle';
            
            const statusElement = document.getElementById('gameStatus');
            statusElement.className = 'game-status';
            statusElement.textContent = 'üéØ Game started! White moves first. Good luck! üéØ';
        }

        // Create flying flowers animation
        function createFlyingFlowers() {
            const flowers = ['üå∏', 'üå∫', 'üåª', 'üå∑', 'üåπ', 'üíê', 'üèµÔ∏è', 'üåº'];
            const flowerCount = 20;
            
            for (let i = 0; i < flowerCount; i++) {
                setTimeout(() => {
                    const flower = document.createElement('div');
                    flower.className = 'flower';
                    flower.textContent = flowers[Math.floor(Math.random() * flowers.length)];
                    flower.style.left = Math.random() * 100 + 'vw';
                    flower.style.animationDelay = Math.random() * 2 + 's';
                    flower.style.animationDuration = (3 + Math.random() * 2) + 's';
                    document.body.appendChild(flower);
                    
                    // Remove flower after animation
                    setTimeout(() => {
                        if (flower.parentNode) {
                            flower.parentNode.removeChild(flower);
                        }
                    }, 5000);
                }, i * 200);
            }
        }

        // Create confetti animation
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#a29bfe', '#fd79a8'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.animationDelay = Math.random() * 1 + 's';
                    confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
                    document.body.appendChild(confetti);
                    
                    // Remove confetti after animation
                    setTimeout(() => {
                        if (confetti.parentNode) {
                            confetti.parentNode.removeChild(confetti);
                        }
                    }, 4000);
                }, i * 50);
            }
        }

        // Show victory popup with celebrations
        function showVictoryPopup(winner, gameType) {
            const popup = document.getElementById('victoryPopup');
            const title = document.getElementById('victoryTitle');
            const message = document.getElementById('victoryMessage');
            
            // Set victory message based on game type
            if (gameType === 'checkmate') {
                title.textContent = 'üèÜ CHECKMATE! üèÜ';
                message.textContent = `${winner} achieves victory through superior strategy!`;
            } else if (gameType === 'timeout') {
                title.textContent = '‚è∞ TIME VICTORY! ‚è∞';
                message.textContent = `${winner} wins as time runs out for the opponent!`;
            } else if (gameType === 'stalemate') {
                title.textContent = 'ü§ù STALEMATE! ü§ù';
                message.textContent = 'An honorable draw - both players fought valiantly!';
            }
            
            // Show popup with animation
            popup.classList.add('show');
            
            // Start celebration animations
            createFlyingFlowers();
            createConfetti();
            
            // Add extra sparkle effects
            setTimeout(() => createConfetti(), 1000);
            setTimeout(() => createFlyingFlowers(), 1500);
        }

        // Close victory popup
        function closeVictoryPopup() {
            const popup = document.getElementById('victoryPopup');
            popup.classList.remove('show');
        }

        // End game with celebration
        function endGame(message, type) {
            gameState.gameOver = true;
            gameState.gameStarted = false;
            gameState.isComputerTurn = false;
            
            // Clear timer
            if (gameState.timer) {
                clearInterval(gameState.timer);
                gameState.timer = null;
            }
            
            const statusElement = document.getElementById('gameStatus');
            statusElement.textContent = message;
            statusElement.className = `game-status ${type}`;
            
            document.querySelectorAll('.player-section').forEach(panel => {
                panel.classList.remove('active');
            });
            
            document.getElementById('thinkingIndicator').classList.remove('show');
            clearHighlights();
            
            // Extract winner from message and show victory popup
            let winner = 'Player';
            if (message.includes('White wins') || message.includes('White')) {
                winner = gameState.gameMode === 'computer' ? 'You' : 'White Player';
            } else if (message.includes('Black wins') || message.includes('Black')) {
                winner = gameState.gameMode === 'computer' ? 'AI Computer' : 'Black Player';
            } else if (message.includes('draw') || message.includes('STALEMATE')) {
                winner = 'Draw';
            }
            
            // Show victory popup after a short delay
            setTimeout(() => {
                showVictoryPopup(winner, type);
            }, 1000);
        }

        // Update game mode display
        function updateGameModeDisplay() {
            const gameMode = document.getElementById('gameMode').value;
            const difficultyControl = document.getElementById('difficultyControl');
            
            if (gameMode === 'computer') {
                difficultyControl.style.display = 'flex';
            } else {
                difficultyControl.style.display = 'none';
            }
        }

        // Event listeners
        document.getElementById('gameMode').addEventListener('change', updateGameModeDisplay);

        // Initialize the game
        gameState.board = initializeBoard();
        renderBoard();
        updateTimerDisplay();
        updateGameModeDisplay();
        updateCapturedPieces();
        updateMoveHistory();
        updateUndoButton();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'966cd480f7c09a83',t:'MTc1Mzc5NDM1MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
